<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Alignment · MoleculeFlow.jl</title><meta name="title" content="Alignment · MoleculeFlow.jl"/><meta property="og:title" content="Alignment · MoleculeFlow.jl"/><meta property="twitter:title" content="Alignment · MoleculeFlow.jl"/><meta name="description" content="Documentation for MoleculeFlow.jl."/><meta property="og:description" content="Documentation for MoleculeFlow.jl."/><meta property="twitter:description" content="Documentation for MoleculeFlow.jl."/><meta property="og:url" content="https://moleculehub.github.io/MoleculeFlow.jl/api/alignment/"/><meta property="twitter:url" content="https://moleculehub.github.io/MoleculeFlow.jl/api/alignment/"/><link rel="canonical" href="https://moleculehub.github.io/MoleculeFlow.jl/api/alignment/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MoleculeFlow.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MoleculeFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../examples/">Practical Examples</a></li><li><a class="tocitem" href="../../for-developers/">For Developers</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../io/">Basic I/O</a></li><li><a class="tocitem" href="../operations/">Molecular Operations</a></li><li><a class="tocitem" href="../reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../drawing/">Drawing &amp; Visualization</a></li><li><a class="tocitem" href="../descriptors/">Molecular Descriptors</a></li><li><a class="tocitem" href="../fingerprints/">Fingerprints</a></li><li><a class="tocitem" href="../pharmacophore/">Pharmacophore Features</a></li><li><a class="tocitem" href="../substructure/">Substructure Search</a></li><li><a class="tocitem" href="../atoms/">Atom Operations</a></li><li><a class="tocitem" href="../bonds/">Bond Operations</a></li><li><a class="tocitem" href="../similarity/">Similarity</a></li><li><a class="tocitem" href="../standardization/">Standardization</a></li><li><a class="tocitem" href="../conformers/">Conformers</a></li><li class="is-active"><a class="tocitem" href>Alignment</a><ul class="internal"><li><a class="tocitem" href="#align_mol"><span>align_mol</span></a></li><li><a class="tocitem" href="#calc_rms"><span>calc_rms</span></a></li><li><a class="tocitem" href="#get_best_rms"><span><code>get_best_rms</code></span></a></li><li><a class="tocitem" href="#get_alignment_transform"><span><code>get_alignment_transform</code></span></a></li><li><a class="tocitem" href="#apply_transform"><span><code>apply_transform</code></span></a></li><li><a class="tocitem" href="#random_transform"><span><code>random_transform</code></span></a></li><li><a class="tocitem" href="#O3AResult"><span>O3AResult</span></a></li><li><a class="tocitem" href="#get_o3a"><span><code>get_o3a</code></span></a></li><li><a class="tocitem" href="#get_crippen_o3a"><span><code>get_crippen_o3a</code></span></a></li><li><a class="tocitem" href="#o3a_align!"><span><code>o3a_align!</code></span></a></li></ul></li><li><a class="tocitem" href="../fragmentation/">Fragmentation</a></li><li><a class="tocitem" href="../graph/">Graph Operations</a></li><li><a class="tocitem" href="../progress/">Progress Tracking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Alignment</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Alignment</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/main/docs/src/api/alignment.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Molecular-Alignment"><a class="docs-heading-anchor" href="#Molecular-Alignment">Molecular Alignment</a><a id="Molecular-Alignment-1"></a><a class="docs-heading-anchor-permalink" href="#Molecular-Alignment" title="Permalink"></a></h1><h2 id="align_mol"><a class="docs-heading-anchor" href="#align_mol">align_mol</a><a id="align_mol-1"></a><a class="docs-heading-anchor-permalink" href="#align_mol" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.align_mol" href="#MoleculeFlow.align_mol"><code>MoleculeFlow.align_mol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align_mol(probe_mol::Molecule, ref_mol::Molecule;
         probe_conf_id::Int=-1, ref_conf_id::Int=-1,
         atom_map=nothing, weights=nothing, reflect::Bool=false,
         max_iterations::Int=50) -&gt; Float64</code></pre><p>Optimally align a probe molecule to a reference molecule to minimize RMSD.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The molecule to be aligned (will be modified in place)</li><li><code>ref_mol::Molecule</code>: The reference molecule to align to (remains unchanged)</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</li><li><code>atom_map=nothing</code>: Optional atom mapping as vector of tuples <code>[(probe_idx, ref_idx), ...]</code> using 1-based indexing</li><li><code>weights=nothing</code>: Optional vector of weights for atoms during alignment (same order as atoms)</li><li><code>reflect::Bool=false</code>: Whether to allow reflection (improper rotations) during alignment</li><li><code>max_iterations::Int=50</code>: Maximum iterations for iterative alignment algorithms</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The root-mean-square deviation (RMSD) after alignment, or <code>Inf</code> if alignment fails</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either molecule is invalid</li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>The probe molecule is modified in place - its coordinates are transformed</li><li>Atom mapping uses 1-based Julia indexing (not 0-based Python indexing)</li><li>Returns <code>Inf</code> if no valid alignment can be found</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic alignment
mol1_base = mol_from_smiles(&quot;CCO&quot;)
mol2_base = mol_from_smiles(&quot;CCO&quot;)
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule
rmsd = align_mol(mol1, mol2)

# Alignment with atom mapping (align first 3 atoms)
atom_map = [(1, 1), (2, 2), (3, 3)]
rmsd = align_mol(mol1, mol2; atom_map = atom_map)

# Alignment allowing reflection
rmsd = align_mol(mol1, mol2; reflect = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L6-L59">source</a></section></article><h2 id="calc_rms"><a class="docs-heading-anchor" href="#calc_rms">calc_rms</a><a id="calc_rms-1"></a><a class="docs-heading-anchor-permalink" href="#calc_rms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.calc_rms" href="#MoleculeFlow.calc_rms"><code>MoleculeFlow.calc_rms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_rms(probe_mol::Molecule, ref_mol::Molecule;
        probe_conf_id::Int=-1, ref_conf_id::Int=-1,
        weights=nothing, transform_probe::Bool=false) -&gt; Float64</code></pre><p>Calculate the root-mean-square distance between two molecules without performing alignment.</p><p>This function computes the RMS distance between corresponding atoms in two molecules. Unlike <code>align_mol</code>, this function does not perform any alignment - it calculates the RMS distance between the molecules in their current orientations. Optionally, it can consider molecular symmetry and transform the probe molecule to find the best RMS.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The probe molecule for comparison</li><li><code>ref_mol::Molecule</code>: The reference molecule for comparison</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</li><li><code>weights=nothing</code>: Optional vector of weights for atoms during calculation</li><li><code>transform_probe::Bool=false</code>: If <code>true</code>, optimally transform the probe to minimize RMS (similar to alignment)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The root-mean-square distance between molecules in Å, or <code>Inf</code> if calculation fails</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either molecule is invalid</li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>If <code>transform_probe=false</code>, calculates RMS in current orientations (no alignment)</li><li>If <code>transform_probe=true</code>, finds optimal transformation to minimize RMS</li><li>Can handle molecular symmetry automatically</li><li>For explicit atom mapping, use the <code>align_mol</code> function instead</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic RMS calculation (no alignment)
mol1_base = mol_from_smiles(&quot;CCO&quot;)
mol2_base = mol_from_smiles(&quot;CCO&quot;)
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule
rms = calc_rms(mol1, mol2)

# RMS with optimal transformation
rms_aligned = calc_rms(mol1, mol2; transform_probe = true)

# RMS with weights
weights = [1.0, 1.0, 2.0]  # Give more weight to the third atom
rms_weighted = calc_rms(mol1, mol2; weights = weights)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L112-L168">source</a></section></article><h2 id="get_best_rms"><a class="docs-heading-anchor" href="#get_best_rms"><code>get_best_rms</code></a><a id="get_best_rms-1"></a><a class="docs-heading-anchor-permalink" href="#get_best_rms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.get_best_rms" href="#MoleculeFlow.get_best_rms"><code>MoleculeFlow.get_best_rms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_best_rms(probe_mol::Molecule, ref_mol::Molecule;
            probe_conf_id::Int=-1, ref_conf_id::Int=-1,
            weights=nothing, max_matches::Int=1000000) -&gt; Float64</code></pre><p>Calculate the best possible RMS between two molecules considering molecular symmetry.</p><p>This function finds the optimal RMS distance by considering all possible symmetry-equivalent alignments between the two molecules. It explores different atom mappings that arise from molecular symmetry to find the minimum possible RMS distance. This is particularly useful for symmetric molecules like benzene where multiple equivalent alignments are possible.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The probe molecule for comparison</li><li><code>ref_mol::Molecule</code>: The reference molecule for comparison</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</li><li><code>weights=nothing</code>: Optional vector of weights for atoms during calculation</li><li><code>max_matches::Int=1000000</code>: Maximum number of symmetry-equivalent matches to consider</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The minimum RMS distance considering all symmetry-equivalent alignments in Å, or <code>Inf</code> if calculation fails</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either molecule is invalid</li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>This function is computationally more expensive than <code>calc_rms</code> as it explores multiple alignments</li><li>Particularly useful for symmetric molecules (e.g., benzene, cyclohexane)</li><li>The probe molecule is transformed to find the best possible alignment</li><li>May take longer for highly symmetric molecules</li><li>For explicit atom mapping, use the <code>align_mol</code> function instead</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Best RMS for symmetric molecules (benzene)
mol1_base = mol_from_smiles(&quot;c1ccccc1&quot;)  # benzene
mol2_base = mol_from_smiles(&quot;c1ccccc1&quot;)  # benzene
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule

# Regular RMS (may not be optimal due to symmetry)
regular_rms = calc_rms(mol1, mol2)

# Best RMS considering symmetry
best_rms = get_best_rms(mol1, mol2)
# best_rms &lt;= regular_rms due to symmetry considerations

# Limit the number of symmetry matches to consider
best_rms_limited = get_best_rms(mol1, mol2; max_matches = 100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L209-L268">source</a></section></article><h2 id="get_alignment_transform"><a class="docs-heading-anchor" href="#get_alignment_transform"><code>get_alignment_transform</code></a><a id="get_alignment_transform-1"></a><a class="docs-heading-anchor-permalink" href="#get_alignment_transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.get_alignment_transform" href="#MoleculeFlow.get_alignment_transform"><code>MoleculeFlow.get_alignment_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_alignment_transform(probe_mol::Molecule, ref_mol::Molecule;
                       probe_conf_id::Int=-1, ref_conf_id::Int=-1,
                       weights=nothing, reflect::Bool=false) -&gt; Matrix{Float64}</code></pre><p>Compute the transformation matrix required to align a probe molecule to a reference molecule.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The molecule to be aligned</li><li><code>ref_mol::Molecule</code>: The reference molecule</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default)</li><li><code>weights=nothing</code>: Optional weights for atoms during alignment</li><li><code>reflect::Bool=false</code>: Whether to allow reflection during alignment</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: 4x4 transformation matrix for the alignment</li></ul><p><strong>Notes</strong></p><ul><li>For explicit atom mapping, use the <code>align_mol</code> function instead</li><li>The transformation matrix can be applied using <code>apply_transform</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol1_base = mol_from_smiles(&quot;CCO&quot;)
mol2_base = mol_from_smiles(&quot;CCO&quot;)
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule
transform = get_alignment_transform(mol1, mol2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L309-L345">source</a></section></article><h2 id="apply_transform"><a class="docs-heading-anchor" href="#apply_transform"><code>apply_transform</code></a><a id="apply_transform-1"></a><a class="docs-heading-anchor-permalink" href="#apply_transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.apply_transform" href="#MoleculeFlow.apply_transform"><code>MoleculeFlow.apply_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_transform(mol::Molecule, transform::Matrix{Float64}; conf_id::Int=-1) -&gt; Molecule</code></pre><p>Apply a transformation matrix to a molecule&#39;s coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>mol::Molecule</code>: The molecule to transform</li><li><code>transform::Matrix{Float64}</code>: 4x4 transformation matrix</li><li><code>conf_id::Int=-1</code>: Conformer ID to transform (-1 for default)</li></ul><p><strong>Returns</strong></p><ul><li><code>Molecule</code>: The transformed molecule (original molecule is also modified)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol_base = mol_from_smiles(&quot;CCO&quot;)
conformers = generate_3d_conformers(mol_base, 1)
mol = conformers[1].molecule
# Get identity transformation as example
transform = Matrix{Float64}(I, 4, 4)
transformed_mol = apply_transform(mol, transform)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L434-L459">source</a></section></article><h2 id="random_transform"><a class="docs-heading-anchor" href="#random_transform"><code>random_transform</code></a><a id="random_transform-1"></a><a class="docs-heading-anchor-permalink" href="#random_transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.random_transform" href="#MoleculeFlow.random_transform"><code>MoleculeFlow.random_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_transform(mol::Molecule; conf_id::Int=-1,
                seed::Union{Int,Nothing}=nothing) -&gt; Molecule</code></pre><p>Perform a random rigid body transformation (rotation + translation) on a molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::Molecule</code>: The molecule to transform</li><li><code>conf_id::Int=-1</code>: Conformer ID to transform (-1 for default)</li><li><code>seed::Union{Int,Nothing}=nothing</code>: Random seed for reproducibility</li></ul><p><strong>Returns</strong></p><ul><li><code>Molecule</code>: The transformed molecule (original molecule is also modified)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol_base = mol_from_smiles(&quot;CCO&quot;)
conformers = generate_3d_conformers(mol_base, 1)
mol = conformers[1].molecule
transformed_mol = random_transform(mol; seed = 42)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L390-L414">source</a></section></article><h2 id="O3AResult"><a class="docs-heading-anchor" href="#O3AResult">O3AResult</a><a id="O3AResult-1"></a><a class="docs-heading-anchor-permalink" href="#O3AResult" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.O3AResult" href="#MoleculeFlow.O3AResult"><code>MoleculeFlow.O3AResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">O3AResult</code></pre><p>Structure to hold results from O3A (Open3DAlign) alignment operations.</p><p><strong>Fields</strong></p><ul><li><code>score::Float64</code>: O3A alignment score (higher values indicate better alignment)</li><li><code>rmsd::Float64</code>: Root Mean Square Deviation after alignment in Å</li><li><code>transform::Matrix{Float64}</code>: 4x4 transformation matrix applied to the probe molecule</li><li><code>matched_atoms::Vector{Tuple{Int,Int}}</code>: Pairs of matched atom indices using 1-based indexing (probe<em>idx, ref</em>idx)</li></ul><p><strong>Notes</strong></p><ul><li>Failed alignments return <code>score = -1.0</code> and <code>rmsd = Inf</code></li><li>The transformation matrix is in homogeneous coordinates format</li><li>Atom indices in <code>matched_atoms</code> use Julia&#39;s 1-based indexing convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L488-L505">source</a></section></article><h2 id="get_o3a"><a class="docs-heading-anchor" href="#get_o3a"><code>get_o3a</code></a><a id="get_o3a-1"></a><a class="docs-heading-anchor-permalink" href="#get_o3a" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.get_o3a" href="#MoleculeFlow.get_o3a"><code>MoleculeFlow.get_o3a</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_o3a(probe_mol::Molecule, ref_mol::Molecule;
       probe_conf_id::Int=-1, ref_conf_id::Int=-1,
       reflect::Bool=false, accuracy::Float64=0.0001,
       attempt_generic_features::Bool=true,
       prune_conformers::Bool=true) -&gt; O3AResult</code></pre><p>Perform Open3DAlign (O3A) alignment using MMFF atom types for molecular overlay. This method aligns molecules based on their 3D pharmacophoric features using MMFF molecular properties to define feature points.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The molecule to be aligned (will be modified in place)</li><li><code>ref_mol::Molecule</code>: The reference molecule to align to (remains unchanged)</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</li><li><code>reflect::Bool=false</code>: Whether to allow reflection during alignment</li><li><code>accuracy::Float64=0.0001</code>: Accuracy threshold for feature matching (currently not used)</li><li><code>attempt_generic_features::Bool=true</code>: Whether to use generic pharmacophoric features (currently not used)</li><li><code>prune_conformers::Bool=true</code>: Whether to prune conformers during alignment (currently not used)</li></ul><p><strong>Returns</strong></p><ul><li><p><code>O3AResult</code>: Structure containing:</p><ul><li><code>score::Float64</code>: O3A alignment score (higher is better)</li><li><code>rmsd::Float64</code>: RMSD after alignment in Å</li><li><code>transform::Matrix{Float64}</code>: 4x4 transformation matrix applied to probe</li><li><code>matched_atoms::Vector{Tuple{Int,Int}}</code>: Pairs of matched atom indices (probe, reference)</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>The probe molecule is modified in place during alignment</li><li>MMFF molecular properties are automatically computed for feature generation</li><li>Returns failed result (score=-1.0, rmsd=Inf) if alignment fails</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol1_base = mol_from_smiles(&quot;c1ccc(cc1)CCN&quot;)  # phenethylamine
mol2_base = mol_from_smiles(&quot;c1ccc(cc1)CCNC&quot;) # N-methylphenethylamine
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule
result = get_o3a(mol1, mol2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L520-L569">source</a></section></article><h2 id="get_crippen_o3a"><a class="docs-heading-anchor" href="#get_crippen_o3a"><code>get_crippen_o3a</code></a><a id="get_crippen_o3a-1"></a><a class="docs-heading-anchor-permalink" href="#get_crippen_o3a" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.get_crippen_o3a" href="#MoleculeFlow.get_crippen_o3a"><code>MoleculeFlow.get_crippen_o3a</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_crippen_o3a(probe_mol::Molecule, ref_mol::Molecule;
                probe_conf_id::Int=-1, ref_conf_id::Int=-1,
                reflect::Bool=false, accuracy::Float64=0.0001,
                attempt_generic_features::Bool=true,
                prune_conformers::Bool=true) -&gt; O3AResult</code></pre><p>Perform Open3DAlign (O3A) alignment using Crippen atom contributions for molecular overlay. This method uses Crippen LogP and molar refractivity contributions to define feature points for pharmacophore-based alignment.</p><p><strong>Arguments</strong></p><ul><li><code>probe_mol::Molecule</code>: The molecule to be aligned (will be modified in place)</li><li><code>ref_mol::Molecule</code>: The reference molecule to align to (remains unchanged)</li><li><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</li><li><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</li><li><code>reflect::Bool=false</code>: Whether to allow reflection during alignment</li><li><code>accuracy::Float64=0.0001</code>: Accuracy threshold for feature matching (currently not used)</li><li><code>attempt_generic_features::Bool=true</code>: Whether to use generic pharmacophoric features (currently not used)</li><li><code>prune_conformers::Bool=true</code>: Whether to prune conformers during alignment (currently not used)</li></ul><p><strong>Returns</strong></p><ul><li><p><code>O3AResult</code>: Structure containing:</p><ul><li><code>score::Float64</code>: O3A alignment score (higher is better)</li><li><code>rmsd::Float64</code>: RMSD after alignment in Å</li><li><code>transform::Matrix{Float64}</code>: 4x4 transformation matrix applied to probe</li><li><code>matched_atoms::Vector{Tuple{Int,Int}}</code>: Pairs of matched atom indices (probe, reference)</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>The probe molecule is modified in place during alignment</li><li>Crippen contributions (LogP and molar refractivity) are automatically computed for feature generation</li><li>Returns failed result (score=-1.0, rmsd=Inf) if alignment fails</li><li>Generally more robust than MMFF-based alignment for diverse molecule types</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol1_base = mol_from_smiles(&quot;CCc1ccccc1&quot;)  # ethylbenzene
mol2_base = mol_from_smiles(&quot;CCc1ccc(O)cc1&quot;)  # 4-ethylphenol
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule
result = get_crippen_o3a(mol1, mol2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L626-L676">source</a></section></article><h2 id="o3a_align!"><a class="docs-heading-anchor" href="#o3a_align!"><code>o3a_align!</code></a><a id="o3a_align!-1"></a><a class="docs-heading-anchor-permalink" href="#o3a_align!" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoleculeFlow.o3a_align!" href="#MoleculeFlow.o3a_align!"><code>MoleculeFlow.o3a_align!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">o3a_align!(probe_mol::Molecule, ref_mol::Molecule, alignment_method::Symbol=:mmff;
          probe_conf_id::Int=-1, ref_conf_id::Int=-1,
          reflect::Bool=false, accuracy::Float64=0.0001) -&gt; O3AResult</code></pre><p>Convenience function to perform O3A (Open3DAlign) alignment and modify the probe molecule in place. This function provides a simple interface to choose between MMFF-based or Crippen-based alignment.</p><p><strong>Arguments</strong></p><ul><li><p><code>probe_mol::Molecule</code>: The molecule to be aligned (will be modified in place)</p></li><li><p><code>ref_mol::Molecule</code>: The reference molecule to align to (remains unchanged)</p></li><li><p><code>alignment_method::Symbol=:mmff</code>: Alignment method (:mmff or :crippen)</p><ul><li><code>:mmff</code>: Uses MMFF molecular properties for feature generation (calls <code>get_o3a</code>)</li><li><code>:crippen</code>: Uses Crippen LogP/molar refractivity contributions (calls <code>get_crippen_o3a</code>)</li></ul></li><li><p><code>probe_conf_id::Int=-1</code>: Conformer ID of the probe molecule (-1 for default/first conformer)</p></li><li><p><code>ref_conf_id::Int=-1</code>: Conformer ID of the reference molecule (-1 for default/first conformer)</p></li><li><p><code>reflect::Bool=false</code>: Whether to allow reflection during alignment</p></li><li><p><code>accuracy::Float64=0.0001</code>: Accuracy threshold for feature matching (currently not used)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>O3AResult</code>: Structure containing:</p><ul><li><code>score::Float64</code>: O3A alignment score (higher is better)</li><li><code>rmsd::Float64</code>: RMSD after alignment in Å</li><li><code>transform::Matrix{Float64}</code>: 4x4 transformation matrix applied to probe</li><li><code>matched_atoms::Vector{Tuple{Int,Int}}</code>: Pairs of matched atom indices (probe, reference)</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Both molecules must have 3D coordinates (conformers)</li><li>The probe molecule is modified in place during alignment</li><li>Returns failed result (score=-1.0, rmsd=Inf) if alignment fails</li><li>For most cases, <code>:crippen</code> method is more robust than <code>:mmff</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mol1_base = mol_from_smiles(&quot;c1ccccc1CCN&quot;)
mol2_base = mol_from_smiles(&quot;c1ccccc1CCNC&quot;)
conformers1 = generate_3d_conformers(mol1_base, 1)
conformers2 = generate_3d_conformers(mol2_base, 1)
mol1 = conformers1[1].molecule
mol2 = conformers2[1].molecule

# MMFF-based alignment
result1 = o3a_align!(mol1, mol2, :mmff)
println(&quot;MMFF result: $(result1)&quot;)

# Crippen-based alignment (generally more robust)
result2 = o3a_align!(mol1, mol2, :crippen)
println(&quot;Crippen result: $(result2)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/b73ee907f4f031a13a59c3fa7feb804f22e692ff/src/molecule/alignment.jl#L733-L788">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conformers/">« Conformers</a><a class="docs-footer-nextpage" href="../fragmentation/">Fragmentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 27 September 2025 05:23">Saturday 27 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
