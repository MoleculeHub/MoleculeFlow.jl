<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Practical Examples · MoleculeFlow.jl</title><meta name="title" content="Practical Examples · MoleculeFlow.jl"/><meta property="og:title" content="Practical Examples · MoleculeFlow.jl"/><meta property="twitter:title" content="Practical Examples · MoleculeFlow.jl"/><meta name="description" content="Documentation for MoleculeFlow.jl."/><meta property="og:description" content="Documentation for MoleculeFlow.jl."/><meta property="twitter:description" content="Documentation for MoleculeFlow.jl."/><meta property="og:url" content="https://moleculehub.github.io/MoleculeFlow.jl/examples/"/><meta property="twitter:url" content="https://moleculehub.github.io/MoleculeFlow.jl/examples/"/><link rel="canonical" href="https://moleculehub.github.io/MoleculeFlow.jl/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MoleculeFlow.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MoleculeFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Practical Examples</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#Basic-Molecule-Management"><span>Basic Molecule Management</span></a></li><li><a class="tocitem" href="#Working-with-Atoms"><span>Working with Atoms</span></a></li><li><a class="tocitem" href="#Working-with-Bonds"><span>Working with Bonds</span></a></li><li><a class="tocitem" href="#Molecular-Properties-and-Descriptors"><span>Molecular Properties and Descriptors</span></a></li><li><a class="tocitem" href="#Substructure-Analysis"><span>Substructure Analysis</span></a></li><li><a class="tocitem" href="#Similarity-and-Fingerprints"><span>Similarity and Fingerprints</span></a></li><li><a class="tocitem" href="#Molecular-Visualization"><span>Molecular Visualization</span></a></li><li><a class="tocitem" href="#Dataset-Analysis"><span>Dataset Analysis</span></a></li><li><a class="tocitem" href="#Molecular-Standardization"><span>Molecular Standardization</span></a></li><li><a class="tocitem" href="#3D-Conformer-Generation"><span>3D Conformer Generation</span></a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/io/">Basic I/O</a></li><li><a class="tocitem" href="../api/drawing/">Drawing &amp; Visualization</a></li><li><a class="tocitem" href="../api/descriptors/">Molecular Descriptors</a></li><li><a class="tocitem" href="../api/fingerprints/">Fingerprints</a></li><li><a class="tocitem" href="../api/substructure/">Substructure Search</a></li><li><a class="tocitem" href="../api/atoms/">Atom Operations</a></li><li><a class="tocitem" href="../api/bonds/">Bond Operations</a></li><li><a class="tocitem" href="../api/similarity/">Similarity</a></li><li><a class="tocitem" href="../api/standardization/">Standardization</a></li><li><a class="tocitem" href="../api/conformers/">Conformers</a></li><li><a class="tocitem" href="../api/graph/">Graph Operations</a></li><li><a class="tocitem" href="../api/progress/">Progress Tracking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Practical Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Practical Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MoleculeHub/MoleculeFlow.jl/blob/main/docs/src/examples.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Practical-Examples"><a class="docs-heading-anchor" href="#Practical-Examples">Practical Examples</a><a id="Practical-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Examples" title="Permalink"></a></h1><p>Here are comprehensive practical examples of using MoleculeFlow.jl for molecular analysis, manipulation, and visualization.</p><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ol><li><a href="#basic-molecule-management">Basic Molecule Management</a></li><li><a href="#working-with-atoms">Working with Atoms</a></li><li><a href="#working-with-bonds">Working with Bonds</a></li><li><a href="#molecular-properties-and-descriptors">Molecular Properties and Descriptors</a></li><li><a href="#substructure-analysis">Substructure Analysis</a></li><li><a href="#similarity-and-fingerprints">Similarity and Fingerprints</a></li><li><a href="#molecular-visualization">Molecular Visualization</a></li><li><a href="#dataset-analysis">Dataset Analysis</a></li><li><a href="#molecular-standardization">Molecular Standardization</a></li><li><a href="#3d-conformer-generation">3D Conformer Generation</a></li></ol><h2 id="Basic-Molecule-Management"><a class="docs-heading-anchor" href="#Basic-Molecule-Management">Basic Molecule Management</a><a id="Basic-Molecule-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Molecule-Management" title="Permalink"></a></h2><h3 id="Creating-and-Validating-Molecules"><a class="docs-heading-anchor" href="#Creating-and-Validating-Molecules">Creating and Validating Molecules</a><a id="Creating-and-Validating-Molecules-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-Validating-Molecules" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MoleculeFlow

# Create molecules from SMILES
ethanol = mol_from_smiles(&quot;CCO&quot;)
benzene = mol_from_smiles(&quot;c1ccccc1&quot;)
invalid_mol = mol_from_smiles(&quot;invalid_smiles&quot;)

# Check validity
println(&quot;Ethanol valid: $(ethanol.valid)&quot;)
println(&quot;Benzene valid: $(benzene.valid)&quot;)
println(&quot;Invalid mol valid: $(invalid_mol.valid)&quot;)

# Access molecule source (original SMILES)
println(&quot;Ethanol source: $(ethanol.source)&quot;)

# Batch creation from SMILES list
smiles_list = [&quot;CCO&quot;, &quot;CCC&quot;, &quot;c1ccccc1&quot;, &quot;CC(=O)O&quot;]
molecules = mol_from_smiles(smiles_list)
valid_molecules = filter(mol -&gt; mol.valid, molecules)</code></pre><h3 id="Converting-Molecules-Back-to-SMILES"><a class="docs-heading-anchor" href="#Converting-Molecules-Back-to-SMILES">Converting Molecules Back to SMILES</a><a id="Converting-Molecules-Back-to-SMILES-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Molecules-Back-to-SMILES" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Convert single molecule
ethanol_smiles = mol_to_smiles(ethanol)
println(&quot;Ethanol SMILES: $ethanol_smiles&quot;)

# Convert multiple molecules
output_smiles = mol_to_smiles(molecules)
println(&quot;Output SMILES: $output_smiles&quot;)

# Generate InChI representation
ethanol_inchi = mol_to_inchi(ethanol)
println(&quot;Ethanol InChI: $ethanol_inchi&quot;)</code></pre><h3 id="Reading-from-SDF-Files"><a class="docs-heading-anchor" href="#Reading-from-SDF-Files">Reading from SDF Files</a><a id="Reading-from-SDF-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-from-SDF-Files" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Read all molecules from an SDF file
# Note: This example assumes you have an SDF file
try
    molecules = read_sdf(&quot;compounds.sdf&quot;)
    println(&quot;Read $(length(molecules)) molecules from SDF&quot;)

    # Filter valid molecules
    valid_molecules = filter(mol -&gt; mol.valid, molecules)
    println(&quot;$(length(valid_molecules)) valid molecules&quot;)

    # Access SDF properties
    for mol in valid_molecules[1:min(3, length(valid_molecules))]
        println(&quot;Molecule: $(mol_to_smiles(mol))&quot;)
        println(&quot;  SDF Index: $(mol.props[:sdf_index])&quot;)
        println(&quot;  Source File: $(mol.props[:source_file])&quot;)

        # Display other SDF properties
        for (key, value) in mol.props
            if key ∉ [:sdf_index, :source_file]
                println(&quot;  $key: $value&quot;)
            end
        end
        println()
    end

catch e
    println(&quot;SDF file not found or error reading: $e&quot;)
end

# Read only first 100 molecules for large files
try
    molecules = read_sdf(&quot;large_database.sdf&quot;, max_mols=100)
    println(&quot;Read first 100 molecules from large SDF&quot;)
catch e
    println(&quot;Large SDF file not found: $e&quot;)
end

# Memory-efficient reading for huge files
try
    next_mol = read_sdf_lazy(&quot;huge_database.sdf&quot;)
    mol_count = 0

    while mol_count &lt; 10  # Process first 10 molecules
        mol = next_mol()
        if mol === nothing
            break  # End of file
        end

        mol_count += 1
        if mol.valid
            smiles = mol_to_smiles(mol)
            println(&quot;Molecule $mol_count: $smiles&quot;)
        end
    end
catch e
    println(&quot;Huge SDF file not found: $e&quot;)
end</code></pre><h3 id="Reading-MOL-Blocks"><a class="docs-heading-anchor" href="#Reading-MOL-Blocks">Reading MOL Blocks</a><a id="Reading-MOL-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-MOL-Blocks" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Example MOL block (ethane)
molblock = &quot;&quot;&quot;

  RDKit          2D

  2  1  0  0  0  0  0  0  0  0999 V2000
    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0
    1.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0
  1  2  1  0
M  END
&quot;&quot;&quot;

mol = mol_from_molblock(molblock)
if mol.valid
    println(&quot;Successfully parsed MOL block&quot;)
    println(&quot;SMILES: $(mol_to_smiles(mol))&quot;)
else
    println(&quot;Failed to parse MOL block&quot;)
end</code></pre><h2 id="Working-with-Atoms"><a class="docs-heading-anchor" href="#Working-with-Atoms">Working with Atoms</a><a id="Working-with-Atoms-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Atoms" title="Permalink"></a></h2><h3 id="Basic-Atom-Access-and-Properties"><a class="docs-heading-anchor" href="#Basic-Atom-Access-and-Properties">Basic Atom Access and Properties</a><a id="Basic-Atom-Access-and-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Atom-Access-and-Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get all atoms from a molecule
caffeine = mol_from_smiles(&quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;)
atoms = get_atoms(caffeine)
println(&quot;Caffeine has $(length(atoms)) atoms&quot;)

# Get specific atom by index (1-based)
first_atom = get_atom(caffeine, 1)
println(&quot;First atom symbol: $(get_symbol(first_atom))&quot;)
println(&quot;First atom atomic number: $(get_atomic_number(first_atom))&quot;)

# Iterate over all atoms
println(&quot;\nAll atoms in caffeine:&quot;)
for (i, atom) in enumerate(atoms)
    symbol = get_symbol(atom)
    atomic_num = get_atomic_number(atom)
    degree = get_degree(atom)
    println(&quot;Atom $i: $symbol (Z=$atomic_num, degree=$degree)&quot;)
end</code></pre><h3 id="Advanced-Atom-Properties"><a class="docs-heading-anchor" href="#Advanced-Atom-Properties">Advanced Atom Properties</a><a id="Advanced-Atom-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Atom-Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get detailed atom properties
for (i, atom) in enumerate(atoms[1:5])  # First 5 atoms
    symbol = get_symbol(atom)
    degree = get_degree(atom)
    valence = get_valence(atom)
    formal_charge = get_formal_charge(atom)
    hybridization = get_hybridization(atom)
    is_aromatic_atom = is_aromatic(atom)
    is_in_ring_atom = is_in_ring(atom)

    println(&quot;Atom $i ($symbol):&quot;)
    println(&quot;Degree: $degree, Valence: $valence&quot;)
    println(&quot;Formal charge: $formal_charge&quot;)
    println(&quot;Hybridization: $hybridization&quot;)
    println(&quot;Aromatic: $is_aromatic_atom, In ring: $is_in_ring_atom&quot;)
    println()
end</code></pre><h3 id="Atom-Neighbors-and-Connectivity"><a class="docs-heading-anchor" href="#Atom-Neighbors-and-Connectivity">Atom Neighbors and Connectivity</a><a id="Atom-Neighbors-and-Connectivity-1"></a><a class="docs-heading-anchor-permalink" href="#Atom-Neighbors-and-Connectivity" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get neighbors of specific atoms
println(&quot;Analyzing atom connectivity:&quot;)
for i in 1:min(5, length(atoms))
    neighbors = get_neighbors(caffeine, i)
    neighbor_symbols = [get_symbol(get_atom(caffeine, j)) for j in neighbors]

    atom_symbol = get_symbol(get_atom(caffeine, i))
    println(&quot;Atom $i ($atom_symbol) connected to: $(join(neighbor_symbols, &quot;, &quot;))&quot;)
end

# Get bonds involving specific atoms
println(&quot;\nBonds from first atom:&quot;)
bonds_from_atom1 = get_bonds_from_atom(caffeine, 1)
for (i, bond) in enumerate(bonds_from_atom1)
    bond_type = get_bond_type(bond)
    begin_atom = get_begin_atom_idx(bond)
    end_atom = get_end_atom_idx(bond)
    println(&quot;Bond $i: Atom $begin_atom - Atom $end_atom ($bond_type)&quot;)
end</code></pre><h3 id="Gasteiger-Partial-Charges"><a class="docs-heading-anchor" href="#Gasteiger-Partial-Charges">Gasteiger Partial Charges</a><a id="Gasteiger-Partial-Charges-1"></a><a class="docs-heading-anchor-permalink" href="#Gasteiger-Partial-Charges" title="Permalink"></a></h3><pre><code class="language-julia hljs">charged_mol = mol_from_smiles(&quot;[NH3+]CCO&quot;)  # Protonated ethylamine
compute_gasteiger_charges!(charged_mol)

atoms = get_atoms(charged_mol)
println(&quot;Gasteiger partial charges:&quot;)
for (i, atom) in enumerate(atoms)
    symbol = get_symbol(atom)
    charge = get_gasteiger_charge(atom)
    println(&quot;Atom $i ($symbol): $charge&quot;)
end</code></pre><h2 id="Working-with-Bonds"><a class="docs-heading-anchor" href="#Working-with-Bonds">Working with Bonds</a><a id="Working-with-Bonds-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Bonds" title="Permalink"></a></h2><h3 id="Basic-Bond-Analysis"><a class="docs-heading-anchor" href="#Basic-Bond-Analysis">Basic Bond Analysis</a><a id="Basic-Bond-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Bond-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">molecule = mol_from_smiles(&quot;CC=C(C)C#N&quot;)

println(&quot;Bond analysis for CC=C(C)C#N:&quot;)
atoms = get_atoms(molecule)
for i in eachindex(atoms)
    bonds = get_bonds_from_atom(molecule, i)
    if !isempty(bonds)
        atom_symbol = get_symbol(get_atom(molecule, i))
        println(&quot;\nAtom $i ($atom_symbol) bonds:&quot;)

        for bond in bonds
            bond_type = get_bond_type(bond)
            begin_idx = get_begin_atom_idx(bond)
            end_idx = get_end_atom_idx(bond)
            is_aromatic_bond = is_aromatic(bond)
            is_in_ring_bond = is_in_ring(bond)

            other_atom_idx = begin_idx == i ? end_idx : begin_idx
            other_symbol = get_symbol(get_atom(molecule, other_atom_idx))

            println(&quot; to Atom $other_atom_idx ($other_symbol): $bond_type&quot; *
                   (is_aromatic_bond ? &quot; (aromatic)&quot; : &quot;&quot;) *
                   (is_in_ring_bond ? &quot; (in ring)&quot; : &quot;&quot;))
        end
    end
end</code></pre><h3 id="Bond-Type-Classification"><a class="docs-heading-anchor" href="#Bond-Type-Classification">Bond Type Classification</a><a id="Bond-Type-Classification-1"></a><a class="docs-heading-anchor-permalink" href="#Bond-Type-Classification" title="Permalink"></a></h3><pre><code class="language-julia hljs">complex_mol = mol_from_smiles(&quot;c1ccc2c(c1)ccc(=O)c2=O&quot;)  # Naphthoquinone

single_bonds = 0
double_bonds = 0
aromatic_bonds = 0
ring_bonds = 0

atoms = get_atoms(complex_mol)
processed_bonds = Set()  # To avoid counting bonds twice

for i in eachindex(atoms)
    bonds = get_bonds_from_atom(complex_mol, i)
    for bond in bonds
        begin_idx = get_begin_atom_idx(bond)
        end_idx = get_end_atom_idx(bond)
        bond_key = (min(begin_idx, end_idx), max(begin_idx, end_idx))

        if bond_key ∉ processed_bonds
            push!(processed_bonds, bond_key)

            bond_type = get_bond_type(bond)
            if bond_type == &quot;SINGLE&quot;
                single_bonds += 1
            elseif bond_type == &quot;DOUBLE&quot;
                double_bonds += 1
            elseif bond_type == &quot;AROMATIC&quot;
                aromatic_bonds += 1
            end

            if is_in_ring(bond)
                ring_bonds += 1
            end
        end
    end
end

println(&quot;Bond analysis for naphthoquinone:&quot;)
println(&quot;Single bonds: $single_bonds&quot;)
println(&quot;Double bonds: $double_bonds&quot;)
println(&quot;Aromatic bonds: $aromatic_bonds&quot;)
println(&quot;Ring bonds: $ring_bonds&quot;)</code></pre><h2 id="Molecular-Properties-and-Descriptors"><a class="docs-heading-anchor" href="#Molecular-Properties-and-Descriptors">Molecular Properties and Descriptors</a><a id="Molecular-Properties-and-Descriptors-1"></a><a class="docs-heading-anchor-permalink" href="#Molecular-Properties-and-Descriptors" title="Permalink"></a></h2><h3 id="Comprehensive-Property-Analysis"><a class="docs-heading-anchor" href="#Comprehensive-Property-Analysis">Comprehensive Property Analysis</a><a id="Comprehensive-Property-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Comprehensive-Property-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">mol = mol_from_smiles(&quot;CCO&quot;)

println(&quot;Molecular Properties Analysis:&quot;)
mw = molecular_weight(mol)
logp_val = logp(mol)
tpsa_val = tpsa(mol)
hbd = num_hbd(mol)
hba = num_hba(mol)
rot_bonds = num_rotatable_bonds(mol)
rings = num_rings(mol)
heavy_atoms = heavy_atom_count(mol)</code></pre><h3 id="Lipinski&#39;s-Rule-of-Five-Analysis"><a class="docs-heading-anchor" href="#Lipinski&#39;s-Rule-of-Five-Analysis">Lipinski&#39;s Rule of Five Analysis</a><a id="Lipinski&#39;s-Rule-of-Five-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Lipinski&#39;s-Rule-of-Five-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">function check_lipinski(mol::Molecule)
    &quot;&quot;&quot;Check if molecule passes Lipinski&#39;s Rule of Five&quot;&quot;&quot;
    if !mol.valid
        return false, &quot;Invalid molecule&quot;
    end

    mw = molecular_weight(mol)
    logp_val = logp(mol)
    hbd = num_hbd(mol)
    hba = num_hba(mol)

    violations = []

    if mw &gt; 500
        push!(violations, &quot;MW &gt; 500 ($(round(mw, digits=1)))&quot;)
    end
    if logp_val &gt; 5
        push!(violations, &quot;LogP &gt; 5 ($(round(logp_val, digits=1)))&quot;)
    end
    if hbd &gt; 5
        push!(violations, &quot;HBD &gt; 5 ($hbd)&quot;)
    end
    if hba &gt; 10
        push!(violations, &quot;HBA &gt; 10 ($hba)&quot;)
    end

    passes = isempty(violations)
    message = passes ? &quot;Passes Lipinski&#39;s Rule of Five&quot; : &quot;Violations: &quot; * join(violations, &quot;, &quot;)

    return passes, message
end

# Test Lipinski&#39;s rule on drug-like molecules
drug_smiles = [
    (&quot;Aspirin&quot;, &quot;CC(=O)Oc1ccccc1C(=O)O&quot;),
    (&quot;Ibuprofen&quot;, &quot;CC(C)Cc1ccc(cc1)C(C)C(=O)O&quot;),
    (&quot;Atorvastatin&quot;, &quot;CC(C)c1c(C(=O)Nc2ccccc2F)c(-c2ccccc2)c(-c2ccc(F)cc2)n1C[C@H](O)C[C@H](O)CC(=O)O&quot;),
    (&quot;Caffeine&quot;, &quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;)
]

println(&quot;\nLipinski&#39;s Rule of Five Analysis:&quot;)
for (name, smiles) in drug_smiles
    mol = mol_from_smiles(smiles)
    passes, message = check_lipinski(mol)
    status = passes ? &quot;PASS&quot; : &quot;FAIL&quot;
    println(&quot;$name: $status&quot;)
    println(&quot;$message&quot;)
    println()
end</code></pre><h2 id="Substructure-Analysis"><a class="docs-heading-anchor" href="#Substructure-Analysis">Substructure Analysis</a><a id="Substructure-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Substructure-Analysis" title="Permalink"></a></h2><h3 id="Finding-Functional-Groups"><a class="docs-heading-anchor" href="#Finding-Functional-Groups">Finding Functional Groups</a><a id="Finding-Functional-Groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Functional-Groups" title="Permalink"></a></h3><pre><code class="language-julia hljs">mol = mol_from_smiles(&quot;C=CC(=O)N1CCC[C@H](C1)N2C3=NC=NC(=C3C(=N2)C4=CC=C(C=C4)OC5=CC=CC=C5)N&quot;) # Ibrutinib

functional_groups_to_check = [
    :alcohol, :carboxylic_acid, :amide, :amine_primary,
    :benzene, :phenol, :ketone, :aldehyde
]

println(&quot;Functional Group Analysis:&quot;)
for fg in functional_groups_to_check
    has_fg = has_functional_group(mol, fg)
    print(fg, &quot;: &quot; ,has_fg, &quot;\n&quot;)
end</code></pre><h3 id="Custom-Substructure-Searches"><a class="docs-heading-anchor" href="#Custom-Substructure-Searches">Custom Substructure Searches</a><a id="Custom-Substructure-Searches-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Substructure-Searches" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Define custom SMARTS patterns
custom_patterns = [
    (&quot;Hydroxyl&quot;, &quot;[OH]&quot;),
    (&quot;Carbonyl&quot;, &quot;C=O&quot;),
    (&quot;Aromatic Ring&quot;, &quot;c1ccccc1&quot;),
    (&quot;Primary Amine&quot;, &quot;[NH2]&quot;),
    (&quot;Ester&quot;, &quot;[CX3](=O)[OX2H0]&quot;),
    (&quot;Benzyl&quot;, &quot;c1ccccc1[CH2]&quot;),
    (&quot;Trifluoromethyl&quot;, &quot;C(F)(F)F&quot;)
]

test_mol = mol_from_smiles(&quot;CC(=O)Oc1ccc(cc1)C(=O)O&quot;)  # Aspirin

println(&quot;Custom substructure analysis for Aspirin:&quot;)
for (name, pattern) in custom_patterns
    matches = get_substructure_matches(test_mol, pattern)
    if !isempty(matches)
        println(&quot;$name: Found $(length(matches)) match(es)&quot;)
        for (i, match) in enumerate(matches)
            println(&quot;  Match $i: atoms $(join(match, &quot;, &quot;))&quot;)
        end
    else
        println(&quot;$name: Not found&quot;)
    end
end</code></pre><h2 id="Similarity-and-Fingerprints"><a class="docs-heading-anchor" href="#Similarity-and-Fingerprints">Similarity and Fingerprints</a><a id="Similarity-and-Fingerprints-1"></a><a class="docs-heading-anchor-permalink" href="#Similarity-and-Fingerprints" title="Permalink"></a></h2><h3 id="Comprehensive-Similarity-Analysis"><a class="docs-heading-anchor" href="#Comprehensive-Similarity-Analysis">Comprehensive Similarity Analysis</a><a id="Comprehensive-Similarity-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Comprehensive-Similarity-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Calculate multiple similarity metrics
mol1 = mol_from_smiles(&quot;CCO&quot;)  # Ethanol
mol2 = mol_from_smiles(&quot;CCC&quot;)  # Propane
mol3 = mol_from_smiles(&quot;CCCO&quot;) # Propanol

molecules = [(&quot;Ethanol&quot;, mol1), (&quot;Propane&quot;, mol2), (&quot;Propanol&quot;, mol3)]

# Calculate different fingerprint types
fingerprint_types = [:morgan, :rdk, :maccs]

println(&quot;Similarity Analysis:&quot;)
for fp_type in fingerprint_types
    println(&quot;\n$fp_type Fingerprints:&quot;)

    # Calculate pairwise similarities
    for i in eachindex(molecules)
        for j in (i+1):length(molecules)
            name1, mol_i = molecules[i]
            name2, mol_j = molecules[j]

            # Calculate different similarity metrics
            tanimoto = tanimoto_similarity(mol_i, mol_j, fingerprint_type=fp_type)
            dice = dice_similarity(mol_i, mol_j, fingerprint_type=fp_type)
            cosine = cosine_similarity(mol_i, mol_j, fingerprint_type=fp_type)

            println(&quot;  $name1 vs $name2:&quot;)
            println(&quot;    Tanimoto: $(round(tanimoto, digits=3))&quot;)
            println(&quot;    Dice: $(round(dice, digits=3))&quot;)
            println(&quot;    Cosine: $(round(cosine, digits=3))&quot;)
        end
    end
end</code></pre><h3 id="Bulk-Similarity-and-Matrix-Calculations"><a class="docs-heading-anchor" href="#Bulk-Similarity-and-Matrix-Calculations">Bulk Similarity and Matrix Calculations</a><a id="Bulk-Similarity-and-Matrix-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Bulk-Similarity-and-Matrix-Calculations" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create a dataset of similar molecules
alcohol_smiles = [&quot;CCO&quot;, &quot;CCCO&quot;, &quot;CC(C)O&quot;, &quot;CCCCO&quot;, &quot;CC(C)CO&quot;, &quot;c1ccc(O)cc1&quot;]
alcohol_mols = mol_from_smiles(alcohol_smiles)
valid_alcohols = filter(mol -&gt; mol.valid, alcohol_mols)

# Query molecule
query = mol_from_smiles(&quot;CCO&quot;)

# Bulk similarity calculation
similarities = bulk_similarity(query, valid_alcohols)
println(&quot;Similarities to ethanol:&quot;)
for (i, sim) in enumerate(similarities)
    smiles = mol_to_smiles(valid_alcohols[i])
    println(&quot;  $smiles: $(round(sim, digits=3))&quot;)
end

# Similarity matrix
sim_matrix = similarity_matrix(valid_alcohols[1:4])  # First 4 molecules
println(&quot;\nSimilarity Matrix (4x4):&quot;)
for i in 1:4
    row = [round(sim_matrix[i, j], digits=3) for j in 1:4]
    println(&quot;  $(join(row, &quot;  &quot;))&quot;)
end</code></pre><h2 id="Molecular-Visualization"><a class="docs-heading-anchor" href="#Molecular-Visualization">Molecular Visualization</a><a id="Molecular-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Molecular-Visualization" title="Permalink"></a></h2><h3 id="Basic-Visualization-Examples"><a class="docs-heading-anchor" href="#Basic-Visualization-Examples">Basic Visualization Examples</a><a id="Basic-Visualization-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Visualization-Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create various molecular images
molecules_to_draw = [
    (&quot;Caffeine&quot;, &quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;),
    (&quot;Aspirin&quot;, &quot;CC(=O)Oc1ccccc1C(=O)O&quot;),
    (&quot;Morphine&quot;, &quot;CN1CC[C@]23c4c5ccc(O)c4O[C@H]2C(=O)CC[C@@]3([C@H]1C5)&quot;)
]

for (name, smiles) in molecules_to_draw
    mol = mol_from_smiles(smiles)
    if mol.valid
        # Generate basic image
        img = mol_to_image(mol, size=(400, 400))

        # Generate SVG
        svg = mol_to_svg(mol, size=(400, 400))

        # Save images (if desired)
        # save_molecule_image(mol, &quot;$name.svg&quot;)

        println(&quot;Generated images for $name&quot;)
    end
end</code></pre><h3 id="Advanced-Visualization-with-Highlighting"><a class="docs-heading-anchor" href="#Advanced-Visualization-with-Highlighting">Advanced Visualization with Highlighting</a><a id="Advanced-Visualization-with-Highlighting-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Visualization-with-Highlighting" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Highlight functional groups
aspirin = mol_from_smiles(&quot;CC(=O)Oc1ccccc1C(=O)O&quot;)

# Find and highlight ester group
ester_matches = get_substructure_matches(aspirin, &quot;[CX3](=O)[OX2H0]&quot;)
if !isempty(ester_matches)
    highlighted_img = mol_to_image(aspirin,
                                  highlight_atoms=ester_matches[1],
                                  size=(500, 500))
    println(&quot;Highlighted ester group in aspirin&quot;)
end

# Create grid of molecules with legends
molecules = [mol_from_smiles(smiles) for (_, smiles) in molecules_to_draw]
names = [name for (name, _) in molecules_to_draw]

grid_img = mols_to_grid_image(molecules,
                             legends=names,
                             mols_per_row=2,
                             sub_img_size=(300, 300))
println(&quot;Created molecular grid&quot;)

# Functional group highlighting
acetaminophen = mol_from_smiles(&quot;CC(=O)Nc1ccc(O)cc1&quot;)
fg_img = draw_functional_groups(acetaminophen,
                               functional_groups=[&quot;[OH]&quot;, &quot;C=O&quot;, &quot;[NH]&quot;],
                               colors=[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;])
println(&quot;Highlighted functional groups in acetaminophen&quot;)</code></pre><h2 id="Dataset-Analysis"><a class="docs-heading-anchor" href="#Dataset-Analysis">Dataset Analysis</a><a id="Dataset-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Analysis" title="Permalink"></a></h2><h3 id="Processing-Molecular-Datasets"><a class="docs-heading-anchor" href="#Processing-Molecular-Datasets">Processing Molecular Datasets</a><a id="Processing-Molecular-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-Molecular-Datasets" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Simulate a small molecular dataset
dataset_smiles = [
    &quot;CCO&quot;, &quot;CCC&quot;, &quot;CCCO&quot;, &quot;CC(C)O&quot;, &quot;CCCCO&quot;,
    &quot;c1ccccc1&quot;, &quot;c1ccc(O)cc1&quot;, &quot;c1ccc(N)cc1&quot;,
    &quot;CC(=O)O&quot;, &quot;CC(=O)N&quot;, &quot;CC(=O)c1ccccc1&quot;,
    &quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;
]

# Create molecules and filter valid ones
molecules = mol_from_smiles(dataset_smiles)
valid_molecules = filter(mol -&gt; mol.valid, molecules)

println(&quot;Dataset Analysis:&quot;)
println(&quot;Total molecules: $(length(dataset_smiles))&quot;)
println(&quot;Valid molecules: $(length(valid_molecules))&quot;)

# Calculate properties for the dataset
properties = []
for mol in valid_molecules
    props = (
        mw = molecular_weight(mol),
        logp = logp(mol),
        tpsa = tpsa(mol),
        hbd = num_hbd(mol),
        hba = num_hba(mol),
        rings = num_rings(mol),
        smiles = mol_to_smiles(mol)
    )
    push!(properties, props)
end

mws = [p.mw for p in properties]
logps = [p.logp for p in properties]</code></pre><h3 id="Clustering-by-Similarity"><a class="docs-heading-anchor" href="#Clustering-by-Similarity">Clustering by Similarity</a><a id="Clustering-by-Similarity-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-by-Similarity" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Simple clustering based on Tanimoto similarity
function simple_clustering(molecules, threshold=0.7)
    clusters = []
    assigned = falses(length(molecules))

    for i in eachindex(molecules)
        if assigned[i]
            continue
        end

        cluster = [i]
        assigned[i] = true

        for j in (i+1):length(molecules)
            if assigned[j]
                continue
            end

            sim = tanimoto_similarity(molecules[i], molecules[j])
            if sim &gt;= threshold
                push!(cluster, j)
                assigned[j] = true
            end
        end

        push!(clusters, cluster)
    end

    return clusters
end

# Apply clustering
clusters = simple_clustering(valid_molecules, 0.5)
println(&quot;\nClustering Results (threshold=0.5):&quot;)
for (i, cluster) in enumerate(clusters)
    println(&quot;Cluster $i ($(length(cluster)) molecules):&quot;)
    for idx in cluster
        smiles = mol_to_smiles(valid_molecules[idx])
        println(&quot;  $smiles&quot;)
    end
    println()
end</code></pre><h2 id="Molecular-Standardization"><a class="docs-heading-anchor" href="#Molecular-Standardization">Molecular Standardization</a><a id="Molecular-Standardization-1"></a><a class="docs-heading-anchor-permalink" href="#Molecular-Standardization" title="Permalink"></a></h2><h3 id="Comprehensive-Standardization-Workflow"><a class="docs-heading-anchor" href="#Comprehensive-Standardization-Workflow">Comprehensive Standardization Workflow</a><a id="Comprehensive-Standardization-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Comprehensive-Standardization-Workflow" title="Permalink"></a></h3><pre><code class="language-julia hljs">messy_molecules = [
    (&quot;Salt mixture&quot;, &quot;CCO.Cl&quot;),
    (&quot;Charged molecule&quot;, &quot;CC(=O)[O-].[Na+]&quot;),
    (&quot;Tautomer&quot;, &quot;CC(O)=CC(=O)C&quot;),
    (&quot;Stereochemistry&quot;, &quot;C[C@H](O)C&quot;)
]

println(&quot;Molecular Standardization Examples:&quot;)
for (name, smiles) in messy_molecules
    mol = mol_from_smiles(smiles)
    if mol.valid
        println(&quot;\n$name: $smiles&quot;)

        # Apply different standardization steps
        stripped = strip_salts(mol)
        canonical = canonical_tautomer(mol)
        neutralized = neutralize_charges(mol)
        normalized = normalize_molecule(mol)

        # Full standardization
        standardized = standardize_molecule(mol)

        println(&quot;Original:      $(mol_to_smiles(mol))&quot;)
        println(&quot;Salt stripped: $(mol_to_smiles(stripped))&quot;)
        println(&quot;Canonical:     $(mol_to_smiles(canonical))&quot;)
        println(&quot;Neutralized:   $(mol_to_smiles(neutralized))&quot;)
        println(&quot;Normalized:    $(mol_to_smiles(normalized))&quot;)
        println(&quot;Standardized:  $(mol_to_smiles(standardized))&quot;)
    end
end

# Batch standardization
batch_smiles = [&quot;CCO.Cl&quot;, &quot;CC(=O)[O-].[Na+]&quot;, &quot;CC(O)=CC(=O)C&quot;]
batch_mols = mol_from_smiles(batch_smiles)
standardized_mols = [standardize_molecule(mol) for mol in batch_mols]

println(&quot;\nBatch Standardization:&quot;)
for (i, (orig, std)) in enumerate(zip(batch_mols, standardized_mols))
    println(&quot;  $i: $(mol_to_smiles(orig)) → $(mol_to_smiles(std))&quot;)
end</code></pre><h2 id="3D-Conformer-Generation"><a class="docs-heading-anchor" href="#3D-Conformer-Generation">3D Conformer Generation</a><a id="3D-Conformer-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Conformer-Generation" title="Permalink"></a></h2><h3 id="Generating-and-Analyzing-Conformers"><a class="docs-heading-anchor" href="#Generating-and-Analyzing-Conformers">Generating and Analyzing Conformers</a><a id="Generating-and-Analyzing-Conformers-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-and-Analyzing-Conformers" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Generate conformers for a flexible molecule
flexible_mol = mol_from_smiles(&quot;CCCCCCCC&quot;)  # Octane

# Generate multiple conformers
conformers = generate_3d_conformers(flexible_mol, 10, optimize=true)

if !isempty(conformers)
    println(&quot;Generated $(length(conformers)) conformers for octane:&quot;)

    for (i, conf_mol) in enumerate(conformers[1:min(5, length(conformers))])  # Show first 5 or fewer
        conf_result = conf_mol.conformer_result
        energy = conf_result.energy
        converged = conf_result.converged ? &quot;✓&quot; : &quot;✗&quot;

        println(&quot;  Conformer $i: $(round(energy, digits=2)) kcal/mol (converged: $converged)&quot;)

        # Access 3D coordinates
        coords = conf_mol.molecule.props[:coordinates_3d]
        println(&quot;    Coordinates shape: $(size(coords))&quot;)
    end

    # Find lowest energy conformer
    best_conf = conformers[1]  # Already sorted by energy
    println(&quot;\nBest conformer energy: $(round(best_conf.conformer_result.energy, digits=2)) kcal/mol&quot;)
end

# 2D coordinate generation
mol_2d = mol_from_smiles(&quot;c1ccc2c(c1)ccc(=O)c2=O&quot;)  # Naphthoquinone
conformers_2d = generate_2d_conformers(mol_2d)

if !isempty(conformers_2d)
    coords_2d = conformers_2d[1].molecule.props[:coordinates_2d]
    println(&quot;\n2D coordinates for naphthoquinone: $(size(coords_2d))&quot;)
end</code></pre><h3 id="Conformer-Energy-Analysis"><a class="docs-heading-anchor" href="#Conformer-Energy-Analysis">Conformer Energy Analysis</a><a id="Conformer-Energy-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Conformer-Energy-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Analyze conformer energies and geometry
if !isempty(conformers)
    energies = [conf.conformer_result.energy for conf in conformers]

    println(&quot;\nConformer Energy Analysis:&quot;)
    println(&quot;  Number of conformers: $(length(energies))&quot;)
    println(&quot;  Energy range: $(round(minimum(energies), digits=2)) - $(round(maximum(energies), digits=2)) kcal/mol&quot;)
    println(&quot;  Energy span: $(round(maximum(energies) - minimum(energies), digits=2)) kcal/mol&quot;)

    # Count converged conformers
    converged_count = sum(conf.conformer_result.converged for conf in conformers)
    println(&quot;  Converged conformers: $converged_count/$(length(conformers))&quot;)

    # Energy distribution
    low_energy = sum(e &lt; (minimum(energies) + 2.0) for e in energies)
    println(&quot;  Low energy conformers (&lt; 2 kcal/mol above minimum): $low_energy&quot;)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../api/io/">Basic I/O »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 16 September 2025 10:29">Tuesday 16 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
