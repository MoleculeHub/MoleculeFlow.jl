var documenterSearchIndex = {"docs":
[{"location":"api/progress/#Progress-Tracking","page":"Progress Tracking","title":"Progress Tracking","text":"","category":"section"},{"location":"api/progress/","page":"Progress Tracking","title":"Progress Tracking","text":"Functions for tracking progress during long-running operations on molecular datasets.","category":"page"},{"location":"api/progress/#Progress-Tracker","page":"Progress Tracking","title":"Progress Tracker","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.ProgressTracker","page":"Progress Tracking","title":"MoleculeFlow.ProgressTracker","text":"ProgressTracker\n\nTracks progress of array processing operations with timing, throughput, and ETA calculations.\n\nFields\n\ntotal_items::Int: Total number of items to process\nprocessed_items::Ref{Int}: Number of items processed so far\nstart_time::Float64: Start time of the operation\nlast_update_time::Ref{Float64}: Last time progress was updated\nupdate_interval::Float64: Minimum seconds between progress updates\nshow_progress::Bool: Whether to display progress information\n\n\n\n\n\n","category":"type"},{"location":"api/progress/#Update-Progress","page":"Progress Tracking","title":"Update Progress","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.update_progress!","page":"Progress Tracking","title":"MoleculeFlow.update_progress!","text":"update_progress!(tracker::ProgressTracker, processed::Int; force::Bool=false)\n\nUpdate the progress tracker with the current number of processed items.\n\nArguments\n\ntracker::ProgressTracker: The progress tracker to update\nprocessed::Int: Current number of processed items\nforce::Bool: Force update even if within update interval\n\n\n\n\n\n","category":"function"},{"location":"api/progress/#Display-Progress","page":"Progress Tracking","title":"Display Progress","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.display_progress","page":"Progress Tracking","title":"MoleculeFlow.display_progress","text":"display_progress(tracker::ProgressTracker)\n\nDisplay current progress information.\n\n\n\n\n\n","category":"function"},{"location":"api/progress/#With-Progress","page":"Progress Tracking","title":"With Progress","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.with_progress","page":"Progress Tracking","title":"MoleculeFlow.with_progress","text":"with_progress(func, items; show_progress=true, desc=\"Processing\")\n\nExecute a function on array items with progress tracking.\n\nArguments\n\nfunc: Function to apply to each item\nitems: Array of items to process\nshow_progress::Bool: Whether to show progress bar\ndesc::String: Description for the progress bar\n\nReturns\n\nArray of results from applying func to each item\n\n\n\n\n\n","category":"function"},{"location":"api/progress/#Map-with-Progress","page":"Progress Tracking","title":"Map with Progress","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.map_with_progress","page":"Progress Tracking","title":"MoleculeFlow.map_with_progress","text":"map_with_progress(func, items...; show_progress=true, desc=\"Processing\")\n\nMap function over arrays with progress tracking (similar to Base.map).\n\nArguments\n\nfunc: Function to apply\nitems...: Arrays to map over\nshow_progress::Bool: Whether to show progress bar\ndesc::String: Description for the progress bar\n\nReturns\n\nArray of results from applying func to items\n\n\n\n\n\n","category":"function"},{"location":"api/progress/#Format-Duration","page":"Progress Tracking","title":"Format Duration","text":"","category":"section"},{"location":"api/progress/#MoleculeFlow.format_duration","page":"Progress Tracking","title":"MoleculeFlow.format_duration","text":"format_duration(seconds::Float64)\n\nFormat duration in seconds to human-readable string.\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Molecular-Fragmentation","page":"Fragmentation","title":"Molecular Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"Functions for fragmenting molecules using various computational approaches.","category":"page"},{"location":"api/fragmentation/#BRICS-Fragmentation","page":"Fragmentation","title":"BRICS Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures) uses retrosynthetic rules to identify breakable bonds in molecules.","category":"page"},{"location":"api/fragmentation/#BRICS-Decompose","page":"Fragmentation","title":"BRICS Decompose","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.brics_decompose","page":"Fragmentation","title":"MoleculeFlow.brics_decompose","text":"brics_decompose(mol::Molecule; min_fragment_size::Int=1, max_fragment_size::Union{Int,Nothing}=nothing) -> Union{Vector{String},Missing}\n\nDecompose a molecule using BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures) rules.\n\nArguments\n\nmol::Molecule: Input molecule to decompose\nmin_fragment_size::Int=1: Minimum number of atoms in returned fragments\nmax_fragment_size::Union{Int,Nothing}=nothing: Maximum number of atoms in returned fragments (nothing for no limit)\n\nReturns\n\nUnion{Vector{String},Missing}: Vector of SMILES strings representing fragments, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCOCCc1ccccc1\")\nfragments = brics_decompose(mol)\n# Returns fragments like [\"CCCO\", \"CCc1ccccc1\", etc.]\n\n# With size constraints\nfragments = brics_decompose(mol; min_fragment_size = 3, max_fragment_size = 10)\n\nNotes\n\nBRICS uses retrosynthetic rules to identify breakable bonds\nReturns canonical SMILES for each fragment\nUseful for fragment-based drug design and retrosynthetic analysis\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#RECAP-Fragmentation","page":"Fragmentation","title":"RECAP Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"RECAP (Retrosynthetic Combinatorial Analysis Procedure) uses different fragmentation rules focused on bonds commonly formed in synthetic chemistry.","category":"page"},{"location":"api/fragmentation/#RECAP-Decompose","page":"Fragmentation","title":"RECAP Decompose","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.recap_decompose","page":"Fragmentation","title":"MoleculeFlow.recap_decompose","text":"recap_decompose(mol::Molecule; min_fragment_size::Int=1) -> Union{Vector{String},Missing}\n\nDecompose a molecule using RECAP (Retrosynthetic Combinatorial Analysis Procedure) rules.\n\nArguments\n\nmol::Molecule: Input molecule to decompose\nmin_fragment_size::Int=1: Minimum number of atoms in returned fragments\n\nReturns\n\nUnion{Vector{String},Missing}: Vector of SMILES strings representing fragments, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCOCCc1ccccc1\")\nfragments = recap_decompose(mol)\n# Returns RECAP fragments\n\nfragments = recap_decompose(mol; min_fragment_size = 5)\n\nNotes\n\nRECAP uses different fragmentation rules compared to BRICS\nFocuses on bonds that are commonly formed in synthetic chemistry\nReturns canonical SMILES for each fragment\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Scaffold-Extraction","page":"Fragmentation","title":"Scaffold Extraction","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"Scaffold extraction methods for identifying core molecular frameworks.","category":"page"},{"location":"api/fragmentation/#Get-Murcko-Scaffold","page":"Fragmentation","title":"Get Murcko Scaffold","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.get_murcko_scaffold","page":"Fragmentation","title":"MoleculeFlow.get_murcko_scaffold","text":"get_murcko_scaffold(mol::Molecule) -> Union{String,Missing}\n\nExtract the Murcko scaffold (framework) from a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{String,Missing}: SMILES string of the Murcko scaffold, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCOCCc1ccc(CC)cc1\")\nscaffold = get_murcko_scaffold(mol)\n# Returns the core ring system: \"c1ccccc1\"\n\nNotes\n\nMurcko scaffolds represent the core ring systems of molecules\nSide chains and functional groups are removed\nUseful for scaffold-based drug design and classification\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Get-Generic-Scaffold","page":"Fragmentation","title":"Get Generic Scaffold","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.get_generic_scaffold","page":"Fragmentation","title":"MoleculeFlow.get_generic_scaffold","text":"get_generic_scaffold(mol::Molecule) -> Union{String,Missing}\n\nExtract the generic Murcko scaffold from a molecule (heteroatoms converted to carbon).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{String,Missing}: SMILES string of the generic scaffold, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCOCCc1ccc(N)cc1\")\ngeneric_scaffold = get_generic_scaffold(mol)\n# Returns generic scaffold with all atoms as carbon\n\nNotes\n\nGeneric scaffolds normalize heteroatoms to carbon\nUseful for finding structurally similar scaffolds regardless of heteroatom identity\nBetter for broad scaffold-based clustering\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Custom-Fragmentation","page":"Fragmentation","title":"Custom Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"Tools for custom fragmentation strategies and fragment manipulation.","category":"page"},{"location":"api/fragmentation/#Fragment-by-Bonds","page":"Fragmentation","title":"Fragment by Bonds","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.fragment_by_bonds","page":"Fragmentation","title":"MoleculeFlow.fragment_by_bonds","text":"fragment_by_bonds(mol::Molecule, bond_indices::Vector{Int}) -> Union{Vector{String},Missing}\n\nFragment a molecule by breaking specific bonds.\n\nArguments\n\nmol::Molecule: Input molecule\nbond_indices::Vector{Int}: Indices of bonds to break (0-based indexing)\n\nReturns\n\nUnion{Vector{String},Missing}: Vector of SMILES strings representing fragments, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCOCCc1ccccc1\")\n# Break bonds at indices 3 and 7\nfragments = fragment_by_bonds(mol, [3, 7])\n\nNotes\n\nBond indices use 0-based indexing (RDKit convention)\nFragments are returned as canonical SMILES\nUseful for custom fragmentation strategies\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Get-Fragment-Count","page":"Fragmentation","title":"Get Fragment Count","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.get_fragment_count","page":"Fragmentation","title":"MoleculeFlow.get_fragment_count","text":"get_fragment_count(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of disconnected fragments in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of disconnected fragments, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO.CCC\")  # Two disconnected fragments\ncount = get_fragment_count(mol)   # Returns 2\n\nNotes\n\nCounts disconnected components in the molecular graph\nUseful for identifying salts, mixtures, or reaction products\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Split-Fragments","page":"Fragmentation","title":"Split Fragments","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.split_fragments","page":"Fragmentation","title":"MoleculeFlow.split_fragments","text":"split_fragments(mol::Molecule) -> Union{Vector{Molecule},Missing}\n\nSplit a molecule into its disconnected fragments.\n\nArguments\n\nmol::Molecule: Input molecule (potentially with disconnected fragments)\n\nReturns\n\nUnion{Vector{Molecule},Missing}: Vector of individual fragment molecules, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO.CCC\")  # Two disconnected fragments\nfragments = split_fragments(mol)\n# Returns [Molecule(CCO), Molecule(CCC)]\n\nNotes\n\nSeparates disconnected molecular components\nEach fragment is returned as a separate Molecule object\nUseful for processing mixtures or salt forms\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Get-Largest-Fragment","page":"Fragmentation","title":"Get Largest Fragment","text":"","category":"section"},{"location":"api/fragmentation/#MoleculeFlow.get_largest_fragment","page":"Fragmentation","title":"MoleculeFlow.get_largest_fragment","text":"get_largest_fragment(mol::Molecule) -> Union{Molecule,Missing}\n\nGet the largest fragment from a molecule (by heavy atom count).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Molecule,Missing}: The largest fragment as a Molecule object, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO.CCCCCCCc1ccccc1\")  # Small and large fragments\nlargest = get_largest_fragment(mol)\n# Returns the larger fragment (CCCCCCCc1ccccc1)\n\nNotes\n\nIdentifies the fragment with the most heavy atoms\nUseful for removing salts or small contaminants\nReturns the original molecule if already connected\n\n\n\n\n\n","category":"function"},{"location":"api/fragmentation/#Usage-Examples","page":"Fragmentation","title":"Usage Examples","text":"","category":"section"},{"location":"api/fragmentation/#Basic-Fragmentation","page":"Fragmentation","title":"Basic Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"using MoleculeFlow\n\n# Create a molecule\nmol = mol_from_smiles(\"CCCOCCc1ccccc1\")\n\n# BRICS fragmentation\nbrics_frags = brics_decompose(mol)\nprintln(\"BRICS fragments: \", brics_frags)\n\n# RECAP fragmentation\nrecap_frags = recap_decompose(mol)\nprintln(\"RECAP fragments: \", recap_frags)\n\n# Extract Murcko scaffold\nscaffold = get_murcko_scaffold(mol)\nprintln(\"Murcko scaffold: \", scaffold)","category":"page"},{"location":"api/fragmentation/#Working-with-Disconnected-Molecules","page":"Fragmentation","title":"Working with Disconnected Molecules","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"# Molecule with disconnected fragments\nmol = mol_from_smiles(\"CCO.CCC.c1ccccc1\")\n\n# Count fragments\ncount = get_fragment_count(mol)\nprintln(\"Number of fragments: \", count)\n\n# Split into individual molecules\nfragments = split_fragments(mol)\nfor (i, frag) in enumerate(fragments)\n    println(\"Fragment $i: \", mol_to_smiles(frag))\nend\n\n# Get the largest fragment\nlargest = get_largest_fragment(mol)\nprintln(\"Largest fragment: \", mol_to_smiles(largest))","category":"page"},{"location":"api/fragmentation/#Advanced-Fragmentation","page":"Fragmentation","title":"Advanced Fragmentation","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"# Custom bond-based fragmentation\nmol = mol_from_smiles(\"CCCCCCCC\")\n\n# Fragment by breaking specific bonds (0-based indexing)\nfragments = fragment_by_bonds(mol, [2, 5])\nprintln(\"Custom fragments: \", fragments)\n\n# Size-constrained BRICS fragmentation\nfragments = brics_decompose(mol, min_fragment_size=3, max_fragment_size=8)\nprintln(\"Size-constrained fragments: \", fragments)","category":"page"},{"location":"api/fragmentation/#Vectorized-Operations","page":"Fragmentation","title":"Vectorized Operations","text":"","category":"section"},{"location":"api/fragmentation/","page":"Fragmentation","title":"Fragmentation","text":"# Process multiple molecules at once\nsmiles_list = [\"CCCOCCc1ccccc1\", \"CC(=O)NCCc1ccccc1\", \"CCCCCC\"]\nmols = mol_from_smiles(smiles_list)\n\n# Get all BRICS fragments\nall_brics = brics_decompose(mols)\nfor (i, frags) in enumerate(all_brics)\n    println(\"Molecule $i BRICS: \", frags)\nend\n\n# Get all scaffolds\nall_scaffolds = get_murcko_scaffold(mols)\nfor (i, scaffold) in enumerate(all_scaffolds)\n    println(\"Molecule $i scaffold: \", scaffold)\nend","category":"page"},{"location":"api/graph/#Graph-Operations","page":"Graph Operations","title":"Graph Operations","text":"","category":"section"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"Functions for converting molecules to graph representations and analyzing molecular graphs.","category":"page"},{"location":"api/graph/#Molecule-to-Graph","page":"Graph Operations","title":"Molecule to Graph","text":"","category":"section"},{"location":"api/graph/#MoleculeFlow.mol_to_graph","page":"Graph Operations","title":"MoleculeFlow.mol_to_graph","text":"mol_to_graph(mol::Molecule; atom_features=false, bond_features=false)\n\nConvert a molecule to a Graph object from Graphs.jl.\n\nArguments\n\nmol::Molecule: The molecule to convert\natom_features::Bool: Whether to include atom features in metadata (default: false)\nbond_features::Bool: Whether to include bond features in metadata (default: false)\n\nReturns\n\nA SimpleGraph or SimpleDiGraph representing the molecular structure\nIf atomfeatures or bondfeatures are true, returns a MetaGraph with features\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\ng = mol_to_graph(mol)\nnv(g)  # number of atoms (vertices)\nne(g)  # number of bonds (edges)\n\n\n\n\n\n","category":"function"},{"location":"api/graph/#Molecule-to-Directed-Graph","page":"Graph Operations","title":"Molecule to Directed Graph","text":"","category":"section"},{"location":"api/graph/#MoleculeFlow.mol_to_digraph","page":"Graph Operations","title":"MoleculeFlow.mol_to_digraph","text":"mol_to_digraph(mol::Molecule; atom_features=false, bond_features=false)\n\nConvert a molecule to a directed Graph object from Graphs.jl. Each bond creates two directed edges (one in each direction).\n\nArguments\n\nmol::Molecule: The molecule to convert\natom_features::Bool: Whether to include atom features in metadata (default: false)\nbond_features::Bool: Whether to include bond features in metadata (default: false)\n\nReturns\n\nA SimpleDiGraph representing the molecular structure\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\ndg = mol_to_digraph(mol)\nnv(dg)  # number of atoms (vertices)\nne(dg)  # number of directed bonds (edges)\n\n\n\n\n\n","category":"function"},{"location":"api/graph/#Graph-Analysis","page":"Graph Operations","title":"Graph Analysis","text":"","category":"section"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"These functions are re-exported from Graphs.jl for convenience when working with molecular graphs:","category":"page"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"nv(g) - Number of vertices (atoms) in the graph\nne(g) - Number of edges (bonds) in the graph\ndensity(g) - Edge density of the graph\nis_connected(g) - Check if the graph is connected\ndiameter(g) - Diameter of the graph\nradius(g) - Radius of the graph","category":"page"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"See the Graphs.jl documentation for complete function documentation.","category":"page"},{"location":"api/graph/#Graph-Matrices","page":"Graph Operations","title":"Graph Matrices","text":"","category":"section"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"These functions are also re-exported from Graphs.jl:","category":"page"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"adjacency_matrix(g) - Adjacency matrix representation\nlaplacian_matrix(g) - Laplacian matrix representation","category":"page"},{"location":"api/graph/#Examples","page":"Graph Operations","title":"Examples","text":"","category":"section"},{"location":"api/graph/","page":"Graph Operations","title":"Graph Operations","text":"using MoleculeFlow\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\ng = mol_to_graph(mol)\n\n# Basic graph properties\nprintln(\"Number of atoms: \", nv(g))     # 6\nprintln(\"Number of bonds: \", ne(g))     # 6\nprintln(\"Is connected: \", is_connected(g))  # true\nprintln(\"Density: \", density(g))        # 0.33\n\n# Graph matrices\nadj_mat = adjacency_matrix(g)\nlap_mat = laplacian_matrix(g)","category":"page"},{"location":"api/bonds/#Bond-Operations","page":"Bond Operations","title":"Bond Operations","text":"","category":"section"},{"location":"api/bonds/","page":"Bond Operations","title":"Bond Operations","text":"Functions for working with bonds between atoms.","category":"page"},{"location":"api/bonds/#Bond-Type","page":"Bond Operations","title":"Bond Type","text":"","category":"section"},{"location":"api/bonds/#MoleculeFlow.Bond","page":"Bond Operations","title":"MoleculeFlow.Bond","text":"Bond\n\nA structure representing a chemical bond between two atoms in a molecule.\n\nFields\n\n_rdkit_bond::Py: The underlying RDKit bond object\nprops::Dict{Symbol, Any}: Dictionary for storing additional bond properties\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\natoms = get_atoms(mol)\nbonds = get_bonds_from_atom(mol, 1)  # Bonds from first atom\nbond = bonds[1]\n\n# Access bond properties\nbond_type = get_bond_type(bond)\nbegin_idx = get_begin_atom_idx(bond)\nend_idx = get_end_atom_idx(bond)\n\n\n\n\n\n","category":"type"},{"location":"api/bonds/#Get-Bond-Type","page":"Bond Operations","title":"Get Bond Type","text":"","category":"section"},{"location":"api/bonds/#MoleculeFlow.get_bond_type","page":"Bond Operations","title":"MoleculeFlow.get_bond_type","text":"get_bond_type(bond::Bond) -> String\n\nGet the bond type as a string.\n\nArguments\n\nbond: A Bond object\n\nReturns\n\nString: The bond type (\"SINGLE\", \"DOUBLE\", \"TRIPLE\", \"AROMATIC\", etc.)\n\nExample\n\nmol = mol_from_smiles(\"C=C\")\nbonds = get_bonds(mol)\nbond_type = get_bond_type(bonds[1])  # Returns \"DOUBLE\"\n\n\n\n\n\n","category":"function"},{"location":"api/bonds/#Get-Begin-Atom-Index","page":"Bond Operations","title":"Get Begin Atom Index","text":"","category":"section"},{"location":"api/bonds/#MoleculeFlow.get_begin_atom_idx","page":"Bond Operations","title":"MoleculeFlow.get_begin_atom_idx","text":"get_begin_atom_idx(bond::Bond) -> Int\n\nGet the index of the first atom in the bond (1-based indexing).\n\nArguments\n\nbond: A Bond object\n\nReturns\n\nInt: The 1-based index of the beginning atom\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nbonds = get_bonds(mol)\nbegin_idx = get_begin_atom_idx(bonds[1])  # Returns 1\n\nConvert to 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"api/bonds/#Get-End-Atom-Index","page":"Bond Operations","title":"Get End Atom Index","text":"","category":"section"},{"location":"api/bonds/#MoleculeFlow.get_end_atom_idx","page":"Bond Operations","title":"MoleculeFlow.get_end_atom_idx","text":"get_end_atom_idx(bond::Bond) -> Int\n\nGet the index of the second atom in the bond (1-based indexing).\n\nArguments\n\nbond: A Bond object\n\nReturns\n\nInt: The 1-based index of the ending atom\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nbonds = get_bonds(mol)\nend_idx = get_end_atom_idx(bonds[1])  # Returns 2\n\nConvert to 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"api/conformers/#Conformer-Generation","page":"Conformers","title":"Conformer Generation","text":"","category":"section"},{"location":"api/conformers/","page":"Conformers","title":"Conformers","text":"Functions for generating 2D and 3D molecular conformations.","category":"page"},{"location":"api/conformers/#Data-Types","page":"Conformers","title":"Data Types","text":"","category":"section"},{"location":"api/conformers/#MoleculeFlow.ConformerResult","page":"Conformers","title":"MoleculeFlow.ConformerResult","text":"ConformerResult\n\nStructure to hold conformer information including ID, energy, and optimization status.\n\nFields\n\nid::Int: Conformer ID (0-based)\nenergy::Float64: Energy in kcal/mol\noptimized::Bool: Whether the conformer has been optimized\nconverged::Bool: Whether optimization converged (if optimized)\n\n\n\n\n\n","category":"type"},{"location":"api/conformers/#MoleculeFlow.ConformerMolecule","page":"Conformers","title":"MoleculeFlow.ConformerMolecule","text":"ConformerMolecule\n\nStructure to hold both conformer metadata and the actual molecule with 3D coordinates.\n\nFields\n\nmolecule::Molecule: The molecule with 3D coordinates stored as properties\nconformer_result::ConformerResult: Metadata about the conformer (ID, energy, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api/conformers/#Generate-3D-Conformers","page":"Conformers","title":"Generate 3D Conformers","text":"","category":"section"},{"location":"api/conformers/#MoleculeFlow.generate_3d_conformers","page":"Conformers","title":"MoleculeFlow.generate_3d_conformers","text":"generate_3d_conformers(mol::Molecule, num_conformers::Int=1; \n                      optimize::Bool=true, force_field::Symbol=:mmff,\n                      max_attempts::Int=1000, random_seed::Union{Int,Nothing}=nothing,\n                      prune_rms_thresh::Float64=1.0, max_iterations::Int=200)\n\nGenerate and optionally optimize 3D conformers for a molecule, returning both the conformer metadata and actual molecules with 3D coordinates stored as properties.\n\nArguments\n\nmol::Molecule: The molecule to generate conformers for\nnum_conformers::Int=1: Number of conformers to generate\noptimize::Bool=true: Whether to optimize conformers after generation\nforce_field::Symbol=:mmff: Force field for optimization (:mmff or :uff)\nmax_attempts::Int=1000: Maximum attempts for conformer generation\nrandom_seed::Union{Int,Nothing}=nothing: Random seed for reproducibility\nprune_rms_thresh::Float64=1.0: RMS threshold for pruning similar conformers\nmax_iterations::Int=200: Maximum optimization iterations\n\nReturns\n\nVector{ConformerMolecule}: Conformer molecules sorted by energy (lowest first)\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nconformer_mols = generate_3d_conformers(mol, 10)\nprintln(\"Best conformer: $(conformer_mols[1].conformer_result)\")\ncoords = conformer_mols[1].molecule.props[:coordinates_3d]\n\n\n\n\n\n","category":"function"},{"location":"api/conformers/#Generate-2D-Conformers","page":"Conformers","title":"Generate 2D Conformers","text":"","category":"section"},{"location":"api/conformers/#MoleculeFlow.generate_2d_conformers","page":"Conformers","title":"MoleculeFlow.generate_2d_conformers","text":"generate_2d_conformers(mol::Molecule) -> Vector{ConformerMolecule}\n\nGenerate 2D coordinates for a molecule using RDKit's 2D coordinate generation.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nVector{ConformerMolecule}: Vector containing a single ConformerMolecule with 2D coordinates\nConformerMolecule[]: Empty vector if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nconformers_2d = generate_2d_conformers(mol)\ncoords = conformers_2d[1].molecule.props[:coordinates_2d]  # 2D coordinates matrix\n\nNotes\n\nGenerates standardized 2D layout for visualization\nCoordinates are stored in the molecule's properties as :coordinates_2d\nAlways returns exactly one conformer (or empty vector if invalid)\nUsed for 2D molecular visualization and plotting\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Similarity-Analysis","page":"Similarity","title":"Similarity Analysis","text":"","category":"section"},{"location":"api/similarity/","page":"Similarity","title":"Similarity","text":"Functions for calculating molecular similarity using various metrics.","category":"page"},{"location":"api/similarity/#Tanimoto-Similarity","page":"Similarity","title":"Tanimoto Similarity","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.tanimoto_similarity","page":"Similarity","title":"MoleculeFlow.tanimoto_similarity","text":"tanimoto_similarity(fp1::Vector{Bool}, fp2::Vector{Bool})\ntanimoto_similarity(mol1::Molecule, mol2::Molecule; fingerprint_type=:morgan, kwargs...)\n\nCalculate the Tanimoto similarity coefficient between two molecules or fingerprints.\n\nThe Tanimoto coefficient is defined as the size of the intersection divided by the size of the union of two sets. For fingerprints, this translates to the number of bits set in both fingerprints divided by the number of bits set in either fingerprint.\n\nArguments\n\nfp1, fp2: Boolean vectors representing molecular fingerprints\nmol1, mol2: Molecule objects to compare\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs, :atom_pair, :topological_torsion)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nFloat64: Similarity score between 0.0 (no similarity) and 1.0 (identical)\nmissing: If either molecule is invalid\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nsimilarity = tanimoto_similarity(mol1, mol2)  # Using Morgan fingerprints by default\nsimilarity_rdk = tanimoto_similarity(mol1, mol2; fingerprint_type = :rdk)\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Dice-Similarity","page":"Similarity","title":"Dice Similarity","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.dice_similarity","page":"Similarity","title":"MoleculeFlow.dice_similarity","text":"dice_similarity(fp1::Vector{Bool}, fp2::Vector{Bool})\ndice_similarity(mol1::Molecule, mol2::Molecule; fingerprint_type=:morgan, kwargs...)\n\nCalculate the Dice similarity coefficient (also known as Sørensen-Dice coefficient) between two molecules or fingerprints.\n\nThe Dice coefficient is defined as twice the size of the intersection divided by the sum of the sizes of the two sets. For fingerprints, this translates to 2 × (number of bits set in both) / (total bits set in both fingerprints).\n\nArguments\n\nfp1, fp2: Boolean vectors representing molecular fingerprints\nmol1, mol2: Molecule objects to compare\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs, :atom_pair, :topological_torsion)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nFloat64: Similarity score between 0.0 (no similarity) and 1.0 (identical)\nmissing: If either molecule is invalid\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nsimilarity = dice_similarity(mol1, mol2)\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Cosine-Similarity","page":"Similarity","title":"Cosine Similarity","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.cosine_similarity","page":"Similarity","title":"MoleculeFlow.cosine_similarity","text":"cosine_similarity(fp1::Vector{Bool}, fp2::Vector{Bool})\ncosine_similarity(mol1::Molecule, mol2::Molecule; fingerprint_type=:morgan, kwargs...)\n\nCalculate the cosine similarity between two molecules or fingerprints.\n\nThe cosine similarity measures the cosine of the angle between two vectors in a multi-dimensional space. For binary fingerprints, this is computed as the dot product divided by the product of the magnitudes.\n\nArguments\n\nfp1, fp2: Boolean vectors representing molecular fingerprints\nmol1, mol2: Molecule objects to compare\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nFloat64: Similarity score between 0.0 (orthogonal) and 1.0 (identical direction)\nmissing: If either molecule is invalid\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nsimilarity = cosine_similarity(mol1, mol2)\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Sokal-Similarity","page":"Similarity","title":"Sokal Similarity","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.sokal_similarity","page":"Similarity","title":"MoleculeFlow.sokal_similarity","text":"sokal_similarity(fp1::Vector{Bool}, fp2::Vector{Bool})\nsokal_similarity(mol1::Molecule, mol2::Molecule; fingerprint_type=:morgan, kwargs...)\n\nCalculate the Sokal similarity coefficient between two molecules or fingerprints.\n\nThe Sokal similarity is defined as intersection / (2 × union - intersection). This metric gives less weight to shared features compared to Tanimoto similarity.\n\nArguments\n\nfp1, fp2: Boolean vectors representing molecular fingerprints\nmol1, mol2: Molecule objects to compare\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nFloat64: Similarity score between 0.0 (no similarity) and 1.0 (identical)\nmissing: If either molecule is invalid\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nsimilarity = sokal_similarity(mol1, mol2)\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Bulk-Similarity","page":"Similarity","title":"Bulk Similarity","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.bulk_similarity","page":"Similarity","title":"MoleculeFlow.bulk_similarity","text":"bulk_similarity(query_mol::Molecule, target_mols::Vector{Molecule};\n               similarity_function=tanimoto_similarity, fingerprint_type=:morgan, kwargs...)\n\nCalculate similarity between one query molecule and a vector of target molecules.\n\nThis function efficiently computes pairwise similarities between a single query molecule and multiple target molecules, useful for similarity searches and ranking.\n\nArguments\n\nquery_mol: The reference molecule to compare against\ntarget_mols: Vector of molecules to compare with the query\nsimilarity_function: Function to use for similarity calculation (default: tanimoto_similarity)\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nVector{Union{Float64,Missing}}: Vector of similarity scores, missing for invalid molecules\n\nExamples\n\nquery = mol_from_smiles(\"CCO\")\ntargets = [mol_from_smiles(\"CCC\"), mol_from_smiles(\"CC\"), mol_from_smiles(\"CCCO\")]\nsimilarities = bulk_similarity(query, targets)\nmost_similar_idx = argmax(similarities)\n\n\n\n\n\n","category":"function"},{"location":"api/similarity/#Similarity-Matrix","page":"Similarity","title":"Similarity Matrix","text":"","category":"section"},{"location":"api/similarity/#MoleculeFlow.similarity_matrix","page":"Similarity","title":"MoleculeFlow.similarity_matrix","text":"similarity_matrix(mols::Vector{Molecule};\n                 similarity_function=tanimoto_similarity, fingerprint_type=:morgan, kwargs...)\n\nCompute a symmetric similarity matrix for a vector of molecules.\n\nThis function creates an n×n symmetric matrix where element (i,j) represents the similarity between molecules i and j. The diagonal elements are always 1.0 (self-similarity).\n\nArguments\n\nmols: Vector of molecules to compare\nsimilarity_function: Function to use for similarity calculation (default: tanimoto_similarity)\nfingerprint_type: Type of fingerprint to use (:morgan, :rdk, :maccs)\nkwargs...: Additional arguments passed to fingerprint generation functions\n\nReturns\n\nMatrix{Union{Float64,Missing}}: Symmetric similarity matrix, missing for invalid molecules\n\nExamples\n\nmols = [mol_from_smiles(\"CCO\"), mol_from_smiles(\"CCC\"), mol_from_smiles(\"CCCO\")]\nsim_matrix = similarity_matrix(mols)\n# Access similarity between molecules 1 and 3\nsim_1_3 = sim_matrix[1, 3]\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Molecular-Standardization","page":"Standardization","title":"Molecular Standardization","text":"","category":"section"},{"location":"api/standardization/","page":"Standardization","title":"Standardization","text":"Functions for cleaning and standardizing molecular structures.","category":"page"},{"location":"api/standardization/#Strip-Salts","page":"Standardization","title":"Strip Salts","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.strip_salts","page":"Standardization","title":"MoleculeFlow.strip_salts","text":"strip_salts(mol::Molecule; largest_fragment_only::Bool=true) -> Molecule\n\nRemove salts and other small fragments from a molecule, keeping only the largest fragment.\n\nArguments\n\nmol::Molecule: Input molecule\nlargest_fragment_only::Bool=true: If true, return only the largest fragment\n\nReturns\n\nMolecule: Molecule with salts removed\n\nExample\n\nmol = mol_from_smiles(\"CCO.Cl\")  # Ethanol with chloride salt\nclean_mol = strip_salts(mol)     # Returns just the ethanol\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Enumerate-Tautomers","page":"Standardization","title":"Enumerate Tautomers","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.enumerate_tautomers","page":"Standardization","title":"MoleculeFlow.enumerate_tautomers","text":"enumerate_tautomers(mol::Molecule; max_tautomers::Int=1000) -> Vector{Molecule}\n\nEnumerate all reasonable tautomers of a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nmax_tautomers::Int=1000: Maximum number of tautomers to generate\n\nReturns\n\nVector{Molecule}: Vector of tautomer molecules\n\nExample\n\nmol = mol_from_smiles(\"CC(=O)CC(=O)C\")  # Acetylacetone\ntautomers = enumerate_tautomers(mol)     # Generates keto-enol tautomers\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Canonical-Tautomer","page":"Standardization","title":"Canonical Tautomer","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.canonical_tautomer","page":"Standardization","title":"MoleculeFlow.canonical_tautomer","text":"canonical_tautomer(mol::Molecule) -> Molecule\n\nGet the canonical tautomer of a molecule according to RDKit's tautomer rules.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nMolecule: Canonical tautomer\n\nExample\n\nmol = mol_from_smiles(\"CC(O)=CC(=O)C\")   # Enol form\ncanonical = canonical_tautomer(mol)      # Returns keto form\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Neutralize-Charges","page":"Standardization","title":"Neutralize Charges","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.neutralize_charges","page":"Standardization","title":"MoleculeFlow.neutralize_charges","text":"neutralize_charges(mol::Molecule) -> Molecule\n\nNeutralize charges in a molecule by adding/removing protons.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nMolecule: Neutralized molecule\n\nExample\n\nmol = mol_from_smiles(\"CC(=O)[O-]\")     # Acetate anion\nneutral = neutralize_charges(mol)       # Returns acetic acid\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Normalize-Molecule","page":"Standardization","title":"Normalize Molecule","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.normalize_molecule","page":"Standardization","title":"MoleculeFlow.normalize_molecule","text":"normalize_molecule(mol::Molecule) -> Molecule\n\nApply RDKit's normalizer to fix common issues in molecular structures.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nMolecule: Normalized molecule\n\nExample\n\nmol = mol_from_smiles(\"c1ccc2c(c1)ccc(=O)c2=O\")  # Quinone\nnormalized = normalize_molecule(mol)               # Applies normalization rules\n\n\n\n\n\n","category":"function"},{"location":"api/standardization/#Standardize-Molecule","page":"Standardization","title":"Standardize Molecule","text":"","category":"section"},{"location":"api/standardization/#MoleculeFlow.standardize_molecule","page":"Standardization","title":"MoleculeFlow.standardize_molecule","text":"standardize_molecule(mol::Molecule; \n                    strip_salts_flag::Bool=true,\n                    canonical_tautomer_flag::Bool=true,\n                    sanitize::Bool=true,\n                    remove_stereochemistry::Bool=false) -> Molecule\n\nPerform comprehensive molecular standardization including salt stripping, tautomer canonicalization, and sanitization.\n\nArguments\n\nmol::Molecule: Input molecule\nstrip_salts_flag::Bool=true: Whether to strip salts and keep largest fragment\ncanonical_tautomer_flag::Bool=true: Whether to canonicalize tautomers\nsanitize::Bool=true: Whether to sanitize the molecule\nremove_stereochemistry::Bool=false: Whether to remove stereochemistry information\n\nReturns\n\nMolecule: Standardized molecule\n\nExample\n\nmol = mol_from_smiles(\"CC(O)=CC(=O)C.Na\")  # Enol form with sodium salt\nstd_mol = standardize_molecule(mol)         # Returns clean, canonical form\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Atom-Operations","page":"Atom Operations","title":"Atom Operations","text":"","category":"section"},{"location":"api/atoms/","page":"Atom Operations","title":"Atom Operations","text":"Functions for working with individual atoms in molecules.","category":"page"},{"location":"api/atoms/#Atom-Type","page":"Atom Operations","title":"Atom Type","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.Atom","page":"Atom Operations","title":"MoleculeFlow.Atom","text":"Atom\n\nA structure representing an individual atom within a molecule.\n\nFields\n\n_rdkit_atom::Py: The underlying RDKit atom object\nprops::Dict{Symbol, Any}: Dictionary for storing additional atom properties\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\natoms = get_atoms(mol)\natom = atoms[1]  # First atom (carbon)\n\n# Access atom properties\nsymbol = get_symbol(atom)\natomic_num = get_atomic_number(atom)\n\n\n\n\n\n","category":"type"},{"location":"api/atoms/#Atom-Access","page":"Atom Operations","title":"Atom Access","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_atoms","page":"Atom Operations","title":"MoleculeFlow.get_atoms","text":"get_atoms(mol::Molecule) -> Union{Vector{Atom}, Missing}\n\nGet all atoms from a molecule as a vector of Atom objects.\n\nArguments\n\nmol: A Molecule object\n\nReturns\n\nVector{Atom}: Vector of all atoms in the molecule\nmissing: If the molecule is invalid\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natoms = get_atoms(mol)  # Returns vector of 3 atoms\nlength(atoms)  # Returns 3\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#MoleculeFlow.get_atom","page":"Atom Operations","title":"MoleculeFlow.get_atom","text":"get_atom(mol::Molecule, idx::Int) -> Union{Atom, Missing}\n\nGet a specific atom from a molecule by its index (1-based).\n\nArguments\n\nmol: A Molecule object\nidx: 1-based index of the atom to retrieve\n\nReturns\n\nAtom: The atom at the specified index\nmissing: If the molecule is invalid\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 1)  # Returns first carbon atom\nsymbol = get_symbol(atom)  # Returns \"C\"\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Atomic-Number","page":"Atom Operations","title":"Get Atomic Number","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_atomic_number","page":"Atom Operations","title":"MoleculeFlow.get_atomic_number","text":"get_atomic_number(atom::Atom) -> Int\n\nGet the atomic number of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The atomic number (number of protons)\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 1)\natomic_num = get_atomic_number(atom)  # Returns 6 for carbon\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Symbol","page":"Atom Operations","title":"Get Symbol","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_symbol","page":"Atom Operations","title":"MoleculeFlow.get_symbol","text":"get_symbol(atom::Atom) -> String\n\nGet the atomic symbol of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nString: The atomic symbol (e.g., \"C\", \"N\", \"O\")\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 3)\nsymbol = get_symbol(atom)  # Returns \"O\" for oxygen\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Mass","page":"Atom Operations","title":"Get Mass","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_mass","page":"Atom Operations","title":"MoleculeFlow.get_mass","text":"get_mass(atom::Atom) -> Float64\n\nGet the atomic mass of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nFloat64: The atomic mass in atomic mass units (amu)\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 1)  # Carbon\nmass = get_mass(atom)  # Returns ~12.011\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Isotope","page":"Atom Operations","title":"Get Isotope","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_isotope","page":"Atom Operations","title":"MoleculeFlow.get_isotope","text":"get_isotope(atom::Atom) -> Int\n\nGet the isotope number of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The isotope number (0 for most common isotope)\n\nExample\n\nmol = mol_from_smiles(\"[13C]\")\natom = get_atom(mol, 1)  # Carbon-13\nisotope = get_isotope(atom)  # Returns 13\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Degree","page":"Atom Operations","title":"Get Degree","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_degree","page":"Atom Operations","title":"MoleculeFlow.get_degree","text":"get_degree(atom::Atom) -> Int\n\nGet the degree (number of bonds) of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The number of bonds connected to this atom\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 1)  # First carbon\ndegree = get_degree(atom)  # Returns 1 (connected to second carbon)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Valence","page":"Atom Operations","title":"Get Valence","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_valence","page":"Atom Operations","title":"MoleculeFlow.get_valence","text":"get_valence(atom::Atom) -> Int\n\nGet the total valence of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The total valence (sum of bond orders)\n\nExample\n\nmol = mol_from_smiles(\"C=O\")\natom = get_atom(mol, 1)  # Carbon\nvalence = get_valence(atom)  # Returns 4\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Formal-Charge","page":"Atom Operations","title":"Get Formal Charge","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_formal_charge","page":"Atom Operations","title":"MoleculeFlow.get_formal_charge","text":"get_formal_charge(atom::Atom) -> Int\n\nGet the formal charge of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The formal charge (-1, 0, +1, etc.)\n\nExample\n\nmol = mol_from_smiles(\"[NH3+]\")\natom = get_atom(mol, 1)\ncharge = get_formal_charge(atom)  # Returns +1\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Hybridization","page":"Atom Operations","title":"Get Hybridization","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_hybridization","page":"Atom Operations","title":"MoleculeFlow.get_hybridization","text":"get_hybridization(atom::Atom) -> String\n\nGet the hybridization state of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nString: The hybridization state (\"SP3\", \"SP2\", \"SP\", \"UNSPECIFIED\", etc.)\n\nExample\n\nmol = mol_from_smiles(\"C=C\")\natom = get_atom(mol, 1)  # Carbon with double bond\nhybridization = get_hybridization(atom)  # Returns \"SP2\"\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Number-of-Explicit-Hydrogens","page":"Atom Operations","title":"Get Number of Explicit Hydrogens","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_num_explicit_hs","page":"Atom Operations","title":"MoleculeFlow.get_num_explicit_hs","text":"get_num_explicit_hs(atom::Atom) -> Int\n\nGet the number of explicit hydrogens attached to an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The number of explicitly specified hydrogen atoms\n\nExample\n\nmol = mol_from_smiles(\"C[H]\")\natom = get_atom(mol, 1)  # Carbon\nexplicit_hs = get_num_explicit_hs(atom)  # Returns 1\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Number-of-Implicit-Hydrogens","page":"Atom Operations","title":"Get Number of Implicit Hydrogens","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_num_implicit_hs","page":"Atom Operations","title":"MoleculeFlow.get_num_implicit_hs","text":"get_num_implicit_hs(atom::Atom) -> Int\n\nGet the number of implicit hydrogens attached to an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The number of implicitly specified hydrogen atoms\n\nExample\n\nmol = mol_from_smiles(\"C\")\natom = get_atom(mol, 1)  # Carbon\nimplicit_hs = get_num_implicit_hs(atom)  # Returns 4 (CH4)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Total-Number-of-Hydrogens","page":"Atom Operations","title":"Get Total Number of Hydrogens","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_total_num_hs","page":"Atom Operations","title":"MoleculeFlow.get_total_num_hs","text":"get_total_num_hs(atom::Atom) -> Int\n\nGet the total number of hydrogens (explicit + implicit) attached to an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The total number of hydrogen atoms attached\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 1)  # First carbon\ntotal_hs = get_total_num_hs(atom)  # Returns 3 (CH3)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-Aromatic","page":"Atom Operations","title":"Is Aromatic","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_aromatic","page":"Atom Operations","title":"MoleculeFlow.is_aromatic","text":"is_aromatic(atom::Atom) -> Bool\n\nCheck if an atom is aromatic.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is aromatic, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\natom = get_atom(mol, 1)  # Aromatic carbon\nis_aromatic(atom)  # Returns true\n\n\n\n\n\nis_aromatic(bond::Bond) -> Bool\n\nCheck if a bond is aromatic.\n\nArguments\n\nbond: A Bond object\n\nReturns\n\nBool: true if the bond is aromatic, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\nbonds = get_bonds(mol)\nis_aromatic(bonds[1])  # Returns true for aromatic C-C bond\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-in-Ring","page":"Atom Operations","title":"Is in Ring","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_in_ring","page":"Atom Operations","title":"MoleculeFlow.is_in_ring","text":"is_in_ring(atom::Atom) -> Bool\n\nCheck if an atom is part of a ring.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is in a ring, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")\natom = get_atom(mol, 1)\nis_in_ring(atom)  # Returns true\n\n\n\n\n\nis_in_ring(bond::Bond) -> Bool\n\nCheck if a bond is part of a ring.\n\nArguments\n\nbond: A Bond object\n\nReturns\n\nBool: true if the bond is in a ring, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\nbonds = get_bonds(mol)\nis_in_ring(bonds[1])  # Returns true\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-in-Ring-Size","page":"Atom Operations","title":"Is in Ring Size","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_in_ring_size","page":"Atom Operations","title":"MoleculeFlow.is_in_ring_size","text":"is_in_ring_size(atom::Atom, size::Int) -> Bool\n\nCheck if an atom is part of a ring of specific size.\n\nArguments\n\natom: An Atom object\nsize: Ring size to check for\n\nReturns\n\nBool: true if the atom is in a ring of the specified size\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene (6-membered ring)\natom = get_atom(mol, 1)\nis_in_ring_size(atom, 6)  # Returns true\nis_in_ring_size(atom, 5)  # Returns false\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Chiral-Tag","page":"Atom Operations","title":"Get Chiral Tag","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_chiral_tag","page":"Atom Operations","title":"MoleculeFlow.get_chiral_tag","text":"get_chiral_tag(atom::Atom) -> String\n\nGet the chirality tag of an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nString: The chirality tag (\"CHIUNSPECIFIED\", \"CHITETRAHEDRALCW\", \"CHITETRAHEDRAL_CCW\", etc.)\n\nExample\n\nmol = mol_from_smiles(\"C[C@H](O)N\")  # Chiral carbon\natom = get_atom(mol, 2)\nchiral_tag = get_chiral_tag(atom)  # Returns chirality information\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Neighbors","page":"Atom Operations","title":"Get Neighbors","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_neighbors","page":"Atom Operations","title":"MoleculeFlow.get_neighbors","text":"get_neighbors(mol::Molecule, atom_idx::Int) -> Union{Vector{Int}, Missing}\n\nGet the indices of neighboring atoms for a given atom.\n\nArguments\n\nmol::Molecule: The molecule containing the atom\natom_idx::Int: 1-based index of the atom\n\nReturns\n\nVector{Int}: Vector of 1-based atom indices that are neighbors to the specified atom\nmissing: If the molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nneighbors = get_neighbors(mol, 1)  # Neighbors of first carbon: [2]\nneighbors = get_neighbors(mol, 2)  # Neighbors of second carbon: [1, 3]\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Bonds-from-Atom","page":"Atom Operations","title":"Get Bonds from Atom","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_bonds_from_atom","page":"Atom Operations","title":"MoleculeFlow.get_bonds_from_atom","text":"get_bonds_from_atom(mol::Molecule, atom_idx::Int) -> Union{Vector{Bond}, Missing}\n\nGet all bonds connected to a specific atom.\n\nArguments\n\nmol::Molecule: The molecule containing the atom\natom_idx::Int: 1-based index of the atom\n\nReturns\n\nVector{Bond}: Vector of Bond objects connected to the specified atom\nmissing: If the molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nbonds = get_bonds_from_atom(mol, 2)  # Bonds from second carbon\nfor bond in bonds\n    bond_type = get_bond_type(bond)\n    println(\"Bond type: \", bond_type)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Number-of-Radical-Electrons","page":"Atom Operations","title":"Get Number of Radical Electrons","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_num_radical_electrons","page":"Atom Operations","title":"MoleculeFlow.get_num_radical_electrons","text":"get_num_radical_electrons(atom::Atom) -> Int\n\nGet the number of radical electrons on an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nInt: The number of radical electrons\n\nExample\n\nmol = mol_from_smiles(\"C[CH2]\")  # Radical carbon\natom = get_atom(mol, 2)\nradicals = get_num_radical_electrons(atom)  # Returns number of unpaired electrons\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-Hetero","page":"Atom Operations","title":"Is Hetero","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_hetero","page":"Atom Operations","title":"MoleculeFlow.is_hetero","text":"is_hetero(atom::Atom) -> Bool\n\nCheck if an atom is a heteroatom (not carbon or hydrogen).\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is a heteroatom, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 3)  # Oxygen\nis_hetero(atom)  # Returns true\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-Hydrogen-Donor","page":"Atom Operations","title":"Is Hydrogen Donor","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_hydrogen_donor","page":"Atom Operations","title":"MoleculeFlow.is_hydrogen_donor","text":"is_hydrogen_donor(atom::Atom) -> Bool\n\nCheck if an atom can act as a hydrogen bond donor.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is a hydrogen bond donor, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\natom = get_atom(mol, 3)  # Oxygen\nis_hydrogen_donor(atom)  # Returns true (OH can donate hydrogen)\n\n# An atom is a hydrogen donor if it's O, N, or S with hydrogens attached\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-Hydrogen-Acceptor","page":"Atom Operations","title":"Is Hydrogen Acceptor","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_hydrogen_acceptor","page":"Atom Operations","title":"MoleculeFlow.is_hydrogen_acceptor","text":"is_hydrogen_acceptor(atom::Atom) -> Bool\n\nCheck if an atom can act as a hydrogen bond acceptor.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is a hydrogen bond acceptor, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"C=O\")\natom = get_atom(mol, 2)  # Oxygen\nis_hydrogen_acceptor(atom)  # Returns true (C=O oxygen can accept hydrogen bonds)\n\n# An atom is a hydrogen acceptor if it's O, N, or F with lone pairs\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Is-Chiral-Center","page":"Atom Operations","title":"Is Chiral Center","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.is_chiral_center","page":"Atom Operations","title":"MoleculeFlow.is_chiral_center","text":"is_chiral_center(atom::Atom) -> Bool\n\nCheck if an atom is a chiral center.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nBool: true if the atom is a chiral center, false otherwise\n\nExample\n\nmol = mol_from_smiles(\"C[C@H](O)N\")  # Chiral carbon\natom = get_atom(mol, 2)\nis_chiral_center(atom)  # Returns true\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-CIP-Code","page":"Atom Operations","title":"Get CIP Code","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_cip_code","page":"Atom Operations","title":"MoleculeFlow.get_cip_code","text":"get_cip_code(atom::Atom) -> Union{String,Missing}\n\nGet the CIP (Cahn-Ingold-Prelog) stereochemistry code for an atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nUnion{String,Missing}: The CIP code (\"R\", \"S\", or missing if not assigned)\n\nExample\n\nmol = mol_from_smiles(\"C[C@H](O)N\")  # Chiral carbon\natom = get_atom(mol, 2)\ncip = get_cip_code(atom)  # Returns \"R\" or \"S\"\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Ring-Size","page":"Atom Operations","title":"Get Ring Size","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_ring_size","page":"Atom Operations","title":"MoleculeFlow.get_ring_size","text":"get_ring_size(atom::Atom) -> Union{Int,Missing}\n\nGet the size of the smallest ring containing the atom.\n\nArguments\n\natom: An Atom object\n\nReturns\n\nUnion{Int,Missing}: The size of the smallest ring, or missing if not in a ring\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\natom = get_atom(mol, 1)\nring_size = get_ring_size(atom)  # Returns 6\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Crippen-LogP-Contribution","page":"Atom Operations","title":"Get Crippen LogP Contribution","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_crippen_log_p_contribution","page":"Atom Operations","title":"MoleculeFlow.get_crippen_log_p_contribution","text":"get_crippen_log_p_contribution(mol::Molecule, atom_idx::Int) -> Union{Float64,Missing}\n\nGet the Crippen LogP contribution for a specific atom.\n\nArguments\n\nmol: A Molecule object\natom_idx: 1-based index of the atom\n\nReturns\n\nUnion{Float64,Missing}: The LogP contribution, or missing if not available\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nlogp_contrib = get_crippen_log_p_contribution(mol, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Crippen-Molar-Refractivity-Contribution","page":"Atom Operations","title":"Get Crippen Molar Refractivity Contribution","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_crippen_molar_refractivity_contribution","page":"Atom Operations","title":"MoleculeFlow.get_crippen_molar_refractivity_contribution","text":"get_crippen_molar_refractivity_contribution(mol::Molecule, atom_idx::Int) -> Union{Float64,Missing}\n\nGet the Crippen molar refractivity contribution for a specific atom.\n\nArguments\n\nmol: A Molecule object\natom_idx: 1-based index of the atom\n\nReturns\n\nUnion{Float64,Missing}: The molar refractivity contribution, or missing if not available\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nmr_contrib = get_crippen_molar_refractivity_contribution(mol, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-TPSA-Contribution","page":"Atom Operations","title":"Get TPSA Contribution","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_tpsa_contribution","page":"Atom Operations","title":"MoleculeFlow.get_tpsa_contribution","text":"get_tpsa_contribution(mol::Molecule, atom_idx::Int) -> Union{Float64,Missing}\n\nGet the TPSA (Topological Polar Surface Area) contribution for a specific atom.\n\nArguments\n\nmol: A Molecule object\natom_idx: 1-based index of the atom\n\nReturns\n\nUnion{Float64,Missing}: The TPSA contribution, or missing if not available\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\ntpsa_contrib = get_tpsa_contribution(mol, 3)  # Oxygen contribution\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Labute-ASA-Contribution","page":"Atom Operations","title":"Get Labute ASA Contribution","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_labute_asa_contribution","page":"Atom Operations","title":"MoleculeFlow.get_labute_asa_contribution","text":"get_labute_asa_contribution(mol::Molecule, atom_idx::Int) -> Union{Float64,Missing}\n\nGet the Labute ASA (Accessible Surface Area) contribution for a specific atom.\n\nArguments\n\nmol: A Molecule object\natom_idx: 1-based index of the atom\n\nReturns\n\nUnion{Float64,Missing}: The ASA contribution, or missing if not available\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nasa_contrib = get_labute_asa_contribution(mol, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-All-Atom-Properties","page":"Atom Operations","title":"Get All Atom Properties","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_all_atom_properties","page":"Atom Operations","title":"MoleculeFlow.get_all_atom_properties","text":"get_all_atom_properties(mol::Molecule, atom_idx::Int) -> Union{Dict{Symbol,Any},Missing}\n\nGet all available properties for a specific atom as a dictionary.\n\nArguments\n\nmol: A Molecule object\natom_idx: 1-based index of the atom\n\nReturns\n\nUnion{Dict{Symbol,Any},Missing}: Dictionary with all atom properties, or missing if invalid\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nprops = get_all_atom_properties(mol, 1)\nprintln(props[:symbol])         # \"C\"\nprintln(props[:hybridization])  # \"SP3\"\nprintln(props[:formal_charge])  # 0\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Compute-Gasteiger-Charges","page":"Atom Operations","title":"Compute Gasteiger Charges","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.compute_gasteiger_charges!","page":"Atom Operations","title":"MoleculeFlow.compute_gasteiger_charges!","text":"compute_gasteiger_charges!(mol::Molecule) -> Nothing\n\nCompute Gasteiger partial charges for all atoms in a molecule.\n\nArguments\n\nmol::Molecule: The molecule to compute charges for (modified in-place)\n\nReturns\n\nNothing\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\ncompute_gasteiger_charges!(mol)\n\n# Now can access charges for individual atoms\natoms = get_atoms(mol)\ncharge = get_gasteiger_charge(atoms[1])  # Charge on first carbon\n\n\n\n\n\n","category":"function"},{"location":"api/atoms/#Get-Gasteiger-Charge","page":"Atom Operations","title":"Get Gasteiger Charge","text":"","category":"section"},{"location":"api/atoms/#MoleculeFlow.get_gasteiger_charge","page":"Atom Operations","title":"MoleculeFlow.get_gasteiger_charge","text":"get_gasteiger_charge(atom::Atom) -> Float64\n\nGet the Gasteiger partial charge for a specific atom.\n\nArguments\n\natom::Atom: The atom to get the charge for\n\nReturns\n\nFloat64: The Gasteiger partial charge\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\ncompute_gasteiger_charges!(mol)  # Must compute charges first\n\natoms = get_atoms(mol)\ncharge_carbon = get_gasteiger_charge(atoms[1])\ncharge_oxygen = get_gasteiger_charge(atoms[3])\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using MoleculeFlow\n\n# Create a molecule from SMILES\nmol = mol_from_smiles(\"CCO\")  # Ethanol\n\n# Check if it's valid\nmol.valid  # true\n\n# Calculate molecular properties\nmw = molecular_weight(mol)     # 46.07 g/mol\nlogp_val = logp(mol)          # -0.31\nhbd = num_hbd(mol)            # 1\n\n# Generate fingerprints\nfp = morgan_fingerprint(mol)   # ECFP4 fingerprint\nmaccs = maccs_fingerprint(mol) # MACCS keys\n\n# Substructure search\nhas_oh = has_substructure_match(mol, \"[OH]\")  # true\n\n# Convert back to SMILES\nsmiles = mol_to_smiles(mol)    # \"CCO\"","category":"page"},{"location":"getting-started/#Working-with-SMILES-Containing-Backslashes","page":"Getting Started","title":"Working with SMILES Containing Backslashes","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"When working with SMILES strings that contain backslashes (e.g., stereochemistry markers), you need to handle Julia's string parsing carefully:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# This will cause a ParseError:\n# mol = mol_from_smiles(\"C\\C=C\\C\")\n\n# Use raw strings (recommended):\n# mol = mol_from_smiles(raw\"C\\C=C\\C\")\n\n# Or escape the backslashes:\n# mol = mol_from_smiles(\"C\\\\C=C\\\\C\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Why this happens: Julia treats \\C as an invalid escape sequence. Raw strings (raw\"...\") tell Julia not to process escape sequences, while doubling backslashes (\\\\) creates a literal backslash.","category":"page"},{"location":"api/fingerprints/#Molecular-Fingerprints","page":"Fingerprints","title":"Molecular Fingerprints","text":"","category":"section"},{"location":"api/fingerprints/","page":"Fingerprints","title":"Fingerprints","text":"Functions for generating molecular fingerprints for similarity analysis and machine learning.","category":"page"},{"location":"api/fingerprints/#Morgan-Fingerprint","page":"Fingerprints","title":"Morgan Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.morgan_fingerprint","page":"Fingerprints","title":"MoleculeFlow.morgan_fingerprint","text":"morgan_fingerprint(mol::Molecule; radius::Int=2, nbits::Int=2048) -> Union{Vector{Bool},Missing}\n\nGenerate Morgan (ECFP - Extended Connectivity Fingerprint) for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nradius::Int=2: Radius for the fingerprint (ECFP4 uses radius=2, ECFP6 uses radius=3)\nnbits::Int=2048: Length of the fingerprint bit vector\n\nReturns\n\nUnion{Vector{Bool},Missing}: Binary fingerprint vector, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = morgan_fingerprint(mol)  # ECFP4 with 2048 bits\nfp6 = morgan_fingerprint(mol; radius = 3)  # ECFP6\n\nNotes\n\nMorgan fingerprints are circular fingerprints based on atom environments\nECFP4 (radius=2) is most commonly used for similarity searches\nHigher radius captures larger molecular fragments    # Use the new MorganGenerator API to avoid deprecation warning\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#MACCS-Fingerprint","page":"Fingerprints","title":"MACCS Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.maccs_fingerprint","page":"Fingerprints","title":"MoleculeFlow.maccs_fingerprint","text":"maccs_fingerprint(mol::Molecule) -> Union{Vector{Bool},Missing}\n\nGenerate MACCS (Molecular ACCess System) keys fingerprint for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Vector{Bool},Missing}: 167-bit MACCS fingerprint, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = maccs_fingerprint(mol)  # 167-bit vector\n\nNotes\n\nMACCS keys are a fixed set of 167 predefined structural patterns\nEach bit represents presence/absence of a specific substructure\nWidely used for similarity searching and clustering\nMore interpretable than Morgan fingerprints\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#RDK-Fingerprint","page":"Fingerprints","title":"RDK Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.rdk_fingerprint","page":"Fingerprints","title":"MoleculeFlow.rdk_fingerprint","text":"rdk_fingerprint(mol::Molecule; nbits::Int=2048, min_path::Int=1, max_path::Int=7) -> Union{Vector{Bool}, Missing}\n\nGenerate an RDKit fingerprint for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nnbits::Int=2048: Number of bits in the fingerprint (will be folded/extended if different from default)\nmin_path::Int=1: Minimum path length (currently not used in newer RDKit)\nmax_path::Int=7: Maximum path length (currently not used in newer RDKit)\n\nReturns\n\nVector{Bool}: Binary fingerprint vector\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = rdk_fingerprint(mol)\nlength(fp)  # 2048\n\nNotes\n\nRDKit fingerprints encode structural features as bit patterns\nBased on linear and branched subgraphs of molecules\nDifferent from Morgan fingerprints in their structural encoding    # GetRDKFingerprint in newer RDKit doesn't support custom parameters like fpSize\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#Atom-Pair-Fingerprint","page":"Fingerprints","title":"Atom Pair Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.atom_pair_fingerprint","page":"Fingerprints","title":"MoleculeFlow.atom_pair_fingerprint","text":"atom_pair_fingerprint(mol::Molecule; nbits::Int=2048) -> Union{Vector{Bool}, Missing}\n\nGenerate an atom pair fingerprint for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nnbits::Int=2048: Number of bits in the fingerprint\n\nReturns\n\nVector{Bool}: Binary fingerprint vector\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = atom_pair_fingerprint(mol)\nlength(fp)  # 2048\n\nNotes\n\nAtom pair fingerprints encode pairs of atoms and the distance between them\nBased on the concept that similar molecules have similar atom pair patterns\nUseful for scaffold hopping and diverse similarity searching\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#Topological-Torsion-Fingerprint","page":"Fingerprints","title":"Topological Torsion Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.topological_torsion_fingerprint","page":"Fingerprints","title":"MoleculeFlow.topological_torsion_fingerprint","text":"topological_torsion_fingerprint(mol::Molecule; nbits::Int=2048) -> Union{Vector{Bool}, Missing}\n\nGenerate a topological torsion fingerprint for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nnbits::Int=2048: Number of bits in the fingerprint\n\nReturns\n\nVector{Bool}: Binary fingerprint vector\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = topological_torsion_fingerprint(mol)\nlength(fp)  # 2048\n\nNotes\n\nTopological torsion fingerprints encode four-atom paths in molecules\nBased on the torsion angles and atom types in these paths\nUseful for 3D pharmacophore-like similarity searching\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#FCFP-Fingerprint","page":"Fingerprints","title":"FCFP Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.fcfp_fingerprint","page":"Fingerprints","title":"MoleculeFlow.fcfp_fingerprint","text":"fcfp_fingerprint(mol::Molecule; radius::Int=2, nbits::Int=2048) -> Union{Vector{Bool}, Missing}\n\nGenerate a Functional-Class FingerPrint (FCFP) for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nradius::Int=2: Radius of the circular fingerprint\nnbits::Int=2048: Number of bits in the fingerprint\n\nReturns\n\nVector{Bool}: Binary fingerprint vector\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = fcfp_fingerprint(mol; radius = 3)\nlength(fp)  # 2048\n\nNotes\n\nFCFP fingerprints are similar to Morgan fingerprints but use functional class atom invariants\nGroups atoms by pharmacophoric features rather than exact atom types\nBetter for finding molecules with similar biological activity    # Use the new MorganGenerator API with feature atom invariants generator to avoid deprecation warning\n\n\n\n\n\n","category":"function"},{"location":"api/fingerprints/#Pattern-Fingerprint","page":"Fingerprints","title":"Pattern Fingerprint","text":"","category":"section"},{"location":"api/fingerprints/#MoleculeFlow.pattern_fingerprint","page":"Fingerprints","title":"MoleculeFlow.pattern_fingerprint","text":"pattern_fingerprint(mol::Molecule; nbits::Int=2048) -> Union{Vector{Bool}, Missing}\n\nGenerate a pattern fingerprint for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nnbits::Int=2048: Number of bits in the fingerprint\n\nReturns\n\nVector{Bool}: Binary fingerprint vector\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nfp = pattern_fingerprint(mol)\nlength(fp)  # 2048\n\nNotes\n\nPattern fingerprints encode molecular substructures as bit patterns\nBased on predefined structural patterns and motifs\nUseful for substructure-based similarity searching\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Molecular-Descriptors","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"Functions for calculating molecular properties and descriptors.","category":"page"},{"location":"api/descriptors/#Molecular-Weight","page":"Molecular Descriptors","title":"Molecular Weight","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.molecular_weight","page":"Molecular Descriptors","title":"MoleculeFlow.molecular_weight","text":"molecular_weight(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the molecular weight of a molecule in Daltons (g/mol).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Molecular weight in g/mol, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nmw = molecular_weight(mol)    # ≈ 46.07 g/mol\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Exact-Molecular-Weight","page":"Molecular Descriptors","title":"Exact Molecular Weight","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.exact_molecular_weight","page":"Molecular Descriptors","title":"MoleculeFlow.exact_molecular_weight","text":"exact_molecular_weight(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the exact molecular weight using isotopic masses.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Exact molecular weight, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nexact_mw = exact_molecular_weight(mol)  # More precise than molecular_weight\n\nNotes\n\nUses exact isotopic masses rather than average atomic weights\nMore precise than molecular_weight for mass spectrometry applications\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Heavy-Atom-Count","page":"Molecular Descriptors","title":"Heavy Atom Count","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.heavy_atom_count","page":"Molecular Descriptors","title":"MoleculeFlow.heavy_atom_count","text":"heavy_atom_count(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of heavy atoms (non-hydrogen atoms) in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of heavy atoms, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\ncount = heavy_atom_count(mol)  # 3 (two carbons and one oxygen)\n\nNotes\n\nHeavy atoms include all atoms except hydrogen\nUseful for drug-like property calculations\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Heteroatoms","page":"Molecular Descriptors","title":"Number of Heteroatoms","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_heteroatoms","page":"Molecular Descriptors","title":"MoleculeFlow.num_heteroatoms","text":"num_heteroatoms(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of heteroatoms (non-carbon heavy atoms) in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of heteroatoms, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nheteroatoms = num_heteroatoms(mol)  # 1 (oxygen)\n\nNotes\n\nHeteroatoms include N, O, S, P, halogens, etc. (everything except C and H)\nImportant for drug-like property calculations\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#LogP","page":"Molecular Descriptors","title":"LogP","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.logp","page":"Molecular Descriptors","title":"MoleculeFlow.logp","text":"logp(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the octanol-water partition coefficient (LogP) using Crippen's method.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: LogP value, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nlp = logp(mol)  # Approximately -0.31\n\nNotes\n\nLogP measures lipophilicity (fat-loving vs water-loving)\nPositive values indicate lipophilic molecules\nNegative values indicate hydrophilic molecules\nImportant for drug absorption and distribution\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#TPSA","page":"Molecular Descriptors","title":"TPSA","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.tpsa","page":"Molecular Descriptors","title":"MoleculeFlow.tpsa","text":"tpsa(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Topological Polar Surface Area (TPSA) in Ų.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: TPSA in Ų, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\narea = tpsa(mol)  # Approximately 20.23 Ų\n\nNotes\n\nTPSA is the polar surface area based on fragment contributions\nImportant for predicting drug permeability  # Topological polar surface area\nValues < 60 Ų typically indicate good oral bioavailability\nUsed in Lipinski's Rule of Five\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Hydrogen-Bond-Donors","page":"Molecular Descriptors","title":"Number of Hydrogen Bond Donors","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_hbd","page":"Molecular Descriptors","title":"MoleculeFlow.num_hbd","text":"num_hbd(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of hydrogen bond donors in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of hydrogen bond donors, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nhbd = num_hbd(mol)  # 1 (the OH group)\n\nNotes\n\nHydrogen bond donors\n\nUsed in Lipinski's Rule of Five (≤5 donors)\nImportant for drug-like properties  # Hydrogen bond donors\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Hydrogen-Bond-Acceptors","page":"Molecular Descriptors","title":"Number of Hydrogen Bond Acceptors","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_hba","page":"Molecular Descriptors","title":"MoleculeFlow.num_hba","text":"num_hba(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of hydrogen bond acceptors in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of hydrogen bond acceptors, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nhba = num_hba(mol)  # 1 (the oxygen)\n\nNotes\n\nHydrogen bond acceptors\n\nUsed in Lipinski's Rule of Five (≤10 acceptors)\nImportant for drug-like properties  # Hydrogen bond acceptors\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Rotatable-Bonds","page":"Molecular Descriptors","title":"Number of Rotatable Bonds","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_rotatable_bonds","page":"Molecular Descriptors","title":"MoleculeFlow.num_rotatable_bonds","text":"num_rotatable_bonds(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of rotatable bonds in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of rotatable bonds, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCC\")  # Butane\nrot_bonds = num_rotatable_bonds(mol)  # 3\n\nNotes\n\nRotatable bonds are single bonds that can freely rotate\nExcludes bonds in rings and bonds to terminal atoms\nImportant for molecular flexibility and drug-like properties\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Rings","page":"Molecular Descriptors","title":"Number of Rings","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_rings","page":"Molecular Descriptors","title":"MoleculeFlow.num_rings","text":"num_rings(mol::Molecule) -> Union{Int,Missing}\n\nCount the total number of rings in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of rings, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"c1ccc2ccccc2c1\")  # Naphthalene\nrings = num_rings(mol)  # 2\n\nNotes\n\nCounts all ring systems (aromatic and aliphatic)\nImportant for drug-like property calculations\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Aromatic-Rings","page":"Molecular Descriptors","title":"Number of Aromatic Rings","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_aromatic_rings","page":"Molecular Descriptors","title":"MoleculeFlow.num_aromatic_rings","text":"num_aromatic_rings(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of aromatic rings in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of aromatic rings, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\naromatic_rings = num_aromatic_rings(mol)  # 1\n\nNotes\n\nOnly counts rings with aromatic character\nImportant for drug design and π-π interactions\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Number-of-Saturated-Rings","page":"Molecular Descriptors","title":"Number of Saturated Rings","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.num_saturated_rings","page":"Molecular Descriptors","title":"MoleculeFlow.num_saturated_rings","text":"num_saturated_rings(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of saturated (aliphatic) rings in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of saturated rings, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"C1CCCCC1\")  # Cyclohexane\nsaturated_rings = num_saturated_rings(mol)  # 1\n\nNotes\n\nOnly counts rings without aromatic character\nIncludes cycloalkanes and saturated heterocycles\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Bertz-CT","page":"Molecular Descriptors","title":"Bertz CT","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.bertz_ct","page":"Molecular Descriptors","title":"MoleculeFlow.bertz_ct","text":"bertz_ct(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the BertzCT molecular complexity descriptor.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: BertzCT complexity score, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\ncomplexity = bertz_ct(mol)\n\nNotes\n\nMeasures molecular complexity based on graph theory  # BertzCT complexity\nHigher values indicate more complex molecular structures\nUseful for drug design and synthesis planning\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Balaban-J","page":"Molecular Descriptors","title":"Balaban J","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.balaban_j","page":"Molecular Descriptors","title":"MoleculeFlow.balaban_j","text":"balaban_j(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Balaban J topological index.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Balaban J index, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCC\")\nbalaban = balaban_j(mol)\n\nNotes\n\nBalaban J index is a topological descriptor\nMeasures molecular branching and connectivity\nUsed in QSAR studies\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Chi0v","page":"Molecular Descriptors","title":"Chi0v","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.chi0v","page":"Molecular Descriptors","title":"MoleculeFlow.chi0v","text":"chi0v(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Chi0v valence connectivity index.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Chi0v connectivity index, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nchi = chi0v(mol)\n\nNotes\n\nChi0v is a valence connectivity index  # Connectivity index\nDescribes molecular connectivity considering valence electrons\nUseful for predicting molecular properties\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Kappa1","page":"Molecular Descriptors","title":"Kappa1","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.kappa1","page":"Molecular Descriptors","title":"MoleculeFlow.kappa1","text":"kappa1(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Kappa1 molecular shape index.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Kappa1 shape index, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCCC\")  # Linear molecule\nkappa = kappa1(mol)  # Higher for linear molecules\n\nNotes\n\nKappa1 describes molecular shape and branching  # Kappa shape index\nHigher values indicate more linear structures\nPart of the Kier and Hall molecular shape indices\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#SlogP-VSA","page":"Molecular Descriptors","title":"SlogP VSA","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.slogp_vsa","page":"Molecular Descriptors","title":"MoleculeFlow.slogp_vsa","text":"slogp_vsa(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the SlogP_VSA1 descriptor (MOE-type descriptor).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: SlogP_VSA1 value, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nvsa = slogp_vsa(mol)\n\nNotes\n\nPart of the MOE-type descriptors family\nCombines surface area and LogP information\nUsed in QSAR modeling\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Calculate-All-Descriptors","page":"Molecular Descriptors","title":"Calculate All Descriptors","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.calc_all_descriptors","page":"Molecular Descriptors","title":"MoleculeFlow.calc_all_descriptors","text":"calc_all_descriptors(mol::Molecule) -> Union{Dict{Symbol,Any},Missing}\n\nCalculate all available molecular descriptors for a molecule using RDKit's CalcMolDescriptors.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Dict{Symbol,Any},Missing}: Dictionary with descriptor names as keys and values (Float64, Int, String, etc.), or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\ndescriptors = calc_all_descriptors(mol)\nprintln(descriptors[:MolWt])       # Molecular weight\nprintln(descriptors[:NumHDonors])  # Hydrogen bond donors\nprintln(descriptors[:TPSA])        # Topological polar surface area\n\nNotes\n\nReturns all available descriptors in a single call\nMore efficient than calling individual descriptor functions\nDescriptor names are converted to symbols for Julia compatibility\nContains 200+ descriptors including all Lipinski, Crippen, and topological descriptors\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Advanced-Drug-like-and-ADMET-Descriptors","page":"Molecular Descriptors","title":"Advanced Drug-like and ADMET Descriptors","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"These descriptors are particularly important for drug discovery and ADMET (Absorption, Distribution, Metabolism, Excretion, Toxicity) prediction.","category":"page"},{"location":"api/descriptors/#Drug-likeness-Scores","page":"Molecular Descriptors","title":"Drug-likeness Scores","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.qed","page":"Molecular Descriptors","title":"MoleculeFlow.qed","text":"qed(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Quantitative Estimate of Drug-likeness (QED) score.\n\nQED combines multiple molecular properties into a single drug-likeness score ranging from 0 (non-drug-like) to 1 (highly drug-like).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: QED score (0-1), or missing if molecule is invalid\n\nExamples\n\naspirin = mol_from_smiles(\"CC(=O)OC1=CC=CC=C1C(=O)O\")\ndrug_score = qed(aspirin)  # ≈ 0.73 (fairly drug-like)\n\nNotes\n\nBased on desirability functions for MW, LogP, HBD, HBA, PSA, rotatable bonds, aromatic rings, and alerts\nHigher scores indicate more drug-like properties\nCommonly used threshold: QED > 0.5 for drug-like compounds\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.synthetic_accessibility","page":"Molecular Descriptors","title":"MoleculeFlow.synthetic_accessibility","text":"synthetic_accessibility(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Synthetic Accessibility Score (SAscore).\n\nSAscore estimates how difficult a compound would be to synthesize, ranging from 1 (very easy) to 10 (very difficult).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: SAscore (1-10 scale), or missing if molecule is invalid\n\nExamples\n\n# Simple molecules are easy to synthesize\nethanol = mol_from_smiles(\"CCO\")\nsa_score = synthetic_accessibility(ethanol)  # ≈ 1.98 (easy)\n\n# Complex natural products are difficult\npaclitaxel = mol_from_smiles(\n    \"CC1=C2[C@H](C(=O)[C@@]3([C@H](C[C@@H]4[C@]([C@H]3[C@@H]([C@@](C2(C)C)(C[C@@H]1OC(=O)[C@@H]([C@H](C5=CC=CC=C5)NC(=O)C6=CC=CC=C6)O)O)OC(=O)C7=CC=CC=C7)(CO4)OC(=O)C)O)C)OC(=O)C\",\n)\nif paclitaxel.valid\n    complex_score = synthetic_accessibility(paclitaxel)  # ≈ 8+ (very difficult)\nend\n\nNotes\n\nBased on fragment contributions and structural complexity\nScores: 1-3 (easy), 4-6 (moderate), 7-10 (difficult)\nTrained on known synthetic compounds vs. non-synthesizable structures\nEssential for virtual screening and drug design\nHelps prioritize synthesizable compounds in large libraries\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Molecular-Complexity-and-3D-Character","page":"Molecular Descriptors","title":"Molecular Complexity and 3D Character","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.fraction_csp3","page":"Molecular Descriptors","title":"MoleculeFlow.fraction_csp3","text":"fraction_csp3(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the fraction of sp3 hybridized carbons.\n\nHigher sp3 fraction correlates with increased drug-likeness and 3D character.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Fraction of sp3 carbons (0-1), or missing if molecule is invalid\n\nExamples\n\ncyclohexane = mol_from_smiles(\"C1CCCCC1\")\nfsp3 = fraction_csp3(cyclohexane)  # 1.0 (all carbons are sp3)\n\nbenzene = mol_from_smiles(\"c1ccccc1\")\nfsp3_benzene = fraction_csp3(benzene)  # 0.0 (all carbons are sp2)\n\nNotes\n\nValues range from 0 (fully aromatic/planar) to 1 (fully saturated)\nDrug-like compounds typically have Fsp3 > 0.25\nImportant for assessing molecular complexity and 3D character\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.labute_asa","page":"Molecular Descriptors","title":"MoleculeFlow.labute_asa","text":"labute_asa(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the Labute Accessible Surface Area.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Accessible surface area in Ų, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nasa = labute_asa(mol)  # Accessible surface area\n\nNotes\n\nEstimates the solvent-accessible surface area\nImportant for understanding molecular size and shape\nCorrelates with solubility and membrane permeability\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.molar_refractivity","page":"Molecular Descriptors","title":"MoleculeFlow.molar_refractivity","text":"molar_refractivity(mol::Molecule) -> Union{Float64,Missing}\n\nCalculate the molar refractivity.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Float64,Missing}: Molar refractivity, or missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nmr = molar_refractivity(mol)  # Molar refractivity value\n\nNotes\n\nRelated to polarizability and molecular volume\nImportant for QSAR modeling\nCorrelates with London dispersion forces\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Advanced-Ring-and-Structure-Counts","page":"Molecular Descriptors","title":"Advanced Ring and Structure Counts","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"More detailed structural analysis beyond basic ring counts.","category":"page"},{"location":"api/descriptors/#MoleculeFlow.num_aliphatic_carbocycles","page":"Molecular Descriptors","title":"MoleculeFlow.num_aliphatic_carbocycles","text":"num_aliphatic_carbocycles(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of aliphatic carbocycles (saturated carbon-only rings).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of aliphatic carbocycles, or missing if molecule is invalid\n\nExamples\n\ncyclohexane = mol_from_smiles(\"C1CCCCC1\")\ncount = num_aliphatic_carbocycles(cyclohexane)  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_aromatic_carbocycles","page":"Molecular Descriptors","title":"MoleculeFlow.num_aromatic_carbocycles","text":"num_aromatic_carbocycles(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of aromatic carbocycles (aromatic carbon-only rings).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of aromatic carbocycles, or missing if molecule is invalid\n\nExamples\n\nbenzene = mol_from_smiles(\"c1ccccc1\")\ncount = num_aromatic_carbocycles(benzene)  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_aromatic_heterocycles","page":"Molecular Descriptors","title":"MoleculeFlow.num_aromatic_heterocycles","text":"num_aromatic_heterocycles(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of aromatic heterocycles (aromatic rings containing heteroatoms).\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of aromatic heterocycles, or missing if molecule is invalid\n\nExamples\n\npyridine = mol_from_smiles(\"c1cccnc1\")\ncount = num_aromatic_heterocycles(pyridine)  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_atom_stereo_centers","page":"Molecular Descriptors","title":"MoleculeFlow.num_atom_stereo_centers","text":"num_atom_stereo_centers(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of defined atom stereocenters.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of defined stereocenters, or missing if molecule is invalid\n\nExamples\n\nchiral_mol = mol_from_smiles(\"C[C@H](O)C\")\ncount = num_atom_stereo_centers(chiral_mol)  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_amide_bonds","page":"Molecular Descriptors","title":"MoleculeFlow.num_amide_bonds","text":"num_amide_bonds(mol::Molecule) -> Union{Int,Missing}\n\nCount the number of amide bonds in the molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nUnion{Int,Missing}: Number of amide bonds, or missing if molecule is invalid\n\nExamples\n\nacetamide = mol_from_smiles(\"CC(=O)N\")\ncount = num_amide_bonds(acetamide)  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#3D-Descriptors","page":"Molecular Descriptors","title":"3D Descriptors","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"These descriptors require 3D coordinates to be present in the molecule.","category":"page"},{"location":"api/descriptors/#MoleculeFlow.asphericity","page":"Molecular Descriptors","title":"MoleculeFlow.asphericity","text":"asphericity(mol::Molecule; conf_id::Int=-1) -> Union{Float64,Missing}\n\nCalculate the asphericity of a molecule from its 3D coordinates.\n\nAsphericity describes how much a molecule deviates from a spherical shape.\n\nArguments\n\nmol::Molecule: Input molecule (must have 3D coordinates)\nconf_id::Int: Conformer ID to use (-1 for default)\n\nReturns\n\nUnion{Float64,Missing}: Asphericity value, or missing if molecule is invalid or lacks 3D coordinates\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nconformers = generate_3d_conformers(mol, 1)\nif !isempty(conformers)\n    mol_3d = conformers[1].molecule\n    asp = asphericity(mol_3d)\nend\n\nNotes\n\nRequires 3D coordinates to be present\nValues range from 0 (perfect sphere) to 1 (linear molecule)\nUseful for describing molecular shape and compactness\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.radius_of_gyration","page":"Molecular Descriptors","title":"MoleculeFlow.radius_of_gyration","text":"radius_of_gyration(mol::Molecule; conf_id::Int=-1) -> Union{Float64,Missing}\n\nCalculate the radius of gyration from 3D coordinates.\n\nArguments\n\nmol::Molecule: Input molecule (must have 3D coordinates)\nconf_id::Int: Conformer ID to use (-1 for default)\n\nReturns\n\nUnion{Float64,Missing}: Radius of gyration, or missing if molecule is invalid or lacks 3D coordinates\n\nNotes\n\nRequires 3D coordinates to be present\nMeasures molecular compactness\nUseful for comparing molecular sizes and shapes\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Examples","page":"Molecular Descriptors","title":"Examples","text":"","category":"section"},{"location":"api/descriptors/#Drug-Discovery-Workflow","page":"Molecular Descriptors","title":"Drug Discovery Workflow","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"using MoleculeFlow\n\n# Analyze drug-like properties\ncompounds = [\n    mol_from_smiles(\"CC(=O)OC1=CC=CC=C1C(=O)O\"),  # Aspirin\n    mol_from_smiles(\"CCO\"),                         # Ethanol\n    mol_from_smiles(\"c1ccc2c(c1)nnnc2N\")           # Drug-like compound\n]\n\nfor (i, mol) in enumerate(compounds)\n    println(\"Compound $i:\")\n    println(\"QED score: \", qed(mol))\n    println(\"SAscore: \", synthetic_accessibility(mol))\n    println(\"Fsp3: \", fraction_csp3(mol))\n    println(\"Aromatic rings: \", num_aromatic_carbocycles(mol))\n    println(\"Stereocenters: \", num_atom_stereo_centers(mol))\n    println()\nend","category":"page"},{"location":"api/descriptors/#3D-Shape-Analysis","page":"Molecular Descriptors","title":"3D Shape Analysis","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"# Generate 3D conformer and analyze shape\nmol = mol_from_smiles(\"CCO\")\nconformers = generate_3d_conformers(mol, 1)\n\nif !isempty(conformers)\n    mol_3d = conformers[1].molecule\n\n    println(\"3D Shape Descriptors:\")\n    println(\"  Asphericity: \", asphericity(mol_3d))\n    println(\"  Radius of gyration: \", radius_of_gyration(mol_3d))\nend","category":"page"},{"location":"api/descriptors/#Comprehensive-Analysis","page":"Molecular Descriptors","title":"Comprehensive Analysis","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"# Calculate multiple advanced descriptors at once\nmol = mol_from_smiles(\"CC1=CC=C(C=C1)C2=CC(=NN2C3=CC=C(C=C3)S(=O)(=O)N)C(F)(F)F\")\n\nprintln(\"Comprehensive Descriptor Analysis:\")\nprintln(\"Drug-likeness (QED): \", qed(mol))\nprintln(\"Synthetic accessibility: \", synthetic_accessibility(mol))\nprintln(\"3D character (Fsp3): \", fraction_csp3(mol))\nprintln(\"Surface area (LabuteASA): \", labute_asa(mol))\nprintln(\"Molar refractivity: \", molar_refractivity(mol))\nprintln(\"Aromatic carbocycles: \", num_aromatic_carbocycles(mol))\nprintln(\"Aromatic heterocycles: \", num_aromatic_heterocycles(mol))\nprintln(\"Amide bonds: \", num_amide_bonds(mol))","category":"page"},{"location":"api/descriptors/#Additional-Molecular-Connectivity-Descriptors","page":"Molecular Descriptors","title":"Additional Molecular Connectivity Descriptors","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"These descriptors provide detailed information about molecular connectivity and shape.","category":"page"},{"location":"api/descriptors/#Chi-Connectivity-Indices","page":"Molecular Descriptors","title":"Chi Connectivity Indices","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.chi0n","page":"Molecular Descriptors","title":"MoleculeFlow.chi0n","text":"chi0n(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi0n molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi1n","page":"Molecular Descriptors","title":"MoleculeFlow.chi1n","text":"chi1n(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi1n molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi2n","page":"Molecular Descriptors","title":"MoleculeFlow.chi2n","text":"chi2n(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi2n molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi3n","page":"Molecular Descriptors","title":"MoleculeFlow.chi3n","text":"chi3n(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi3n molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi4n","page":"Molecular Descriptors","title":"MoleculeFlow.chi4n","text":"chi4n(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi4n molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi1v","page":"Molecular Descriptors","title":"MoleculeFlow.chi1v","text":"chi1v(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi1v valence molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi2v","page":"Molecular Descriptors","title":"MoleculeFlow.chi2v","text":"chi2v(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi2v valence molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi3v","page":"Molecular Descriptors","title":"MoleculeFlow.chi3v","text":"chi3v(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi3v valence molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.chi4v","page":"Molecular Descriptors","title":"MoleculeFlow.chi4v","text":"chi4v(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Chi4v valence molecular connectivity index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Kappa-Shape-Descriptors","page":"Molecular Descriptors","title":"Kappa Shape Descriptors","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.kappa2","page":"Molecular Descriptors","title":"MoleculeFlow.kappa2","text":"kappa2(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Kappa2 shape index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.kappa3","page":"Molecular Descriptors","title":"MoleculeFlow.kappa3","text":"kappa3(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Kappa3 shape index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#E-State-Descriptors","page":"Molecular Descriptors","title":"E-State Descriptors","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.max_e_state_index","page":"Molecular Descriptors","title":"MoleculeFlow.max_e_state_index","text":"max_e_state_index(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the maximum E-state index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.min_e_state_index","page":"Molecular Descriptors","title":"MoleculeFlow.min_e_state_index","text":"min_e_state_index(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the minimum E-state index.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Information-Content","page":"Molecular Descriptors","title":"Information Content","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.ipc","page":"Molecular Descriptors","title":"MoleculeFlow.ipc","text":"ipc(mol::Union{Molecule, Missing}) -> Union{Float64, Missing}\n\nCalculate the Information Content of the distance degree sequence (IPC).\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Atom-Counts","page":"Molecular Descriptors","title":"Atom Counts","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"Simple but useful atom counting functions for chemical analysis.","category":"page"},{"location":"api/descriptors/#MoleculeFlow.num_carbons","page":"Molecular Descriptors","title":"MoleculeFlow.num_carbons","text":"num_carbons(mol::Union{Molecule, Missing}) -> Union{Int, Missing}\n\nCount the number of carbon atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_nitrogens","page":"Molecular Descriptors","title":"MoleculeFlow.num_nitrogens","text":"num_nitrogens(mol::Union{Molecule, Missing}) -> Union{Int, Missing}\n\nCount the number of nitrogen atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_oxygens","page":"Molecular Descriptors","title":"MoleculeFlow.num_oxygens","text":"num_oxygens(mol::Union{Molecule, Missing}) -> Union{Int, Missing}\n\nCount the number of oxygen atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_sulfurs","page":"Molecular Descriptors","title":"MoleculeFlow.num_sulfurs","text":"num_sulfurs(mol::Union{Molecule, Missing}) -> Union{Int, Missing}\n\nCount the number of sulfur atoms.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#MoleculeFlow.num_halogens","page":"Molecular Descriptors","title":"MoleculeFlow.num_halogens","text":"num_halogens(mol::Union{Molecule, Missing}) -> Union{Int, Missing}\n\nCount the number of halogen atoms (F, Cl, Br, I, At).\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Get-Address","page":"Molecular Descriptors","title":"Get Address","text":"","category":"section"},{"location":"api/descriptors/#MoleculeFlow.get_address","page":"Molecular Descriptors","title":"MoleculeFlow.get_address","text":"get_address(mol::Union{Molecule, Missing}) -> Union{String, Missing}\nget_address(mol_list::Vector{Union{Molecule, Missing}}) -> Vector{Union{String, Missing}}\n\nExtract the memory address of the underlying RDKit molecule object.\n\nArguments\n\nmol: A Molecule object or Missing\nmol_list: Vector of Molecule objects or Missing values\n\nReturns\n\nString: Hexadecimal memory address (e.g., \"0x1a2b3c4d\")\nmissing: If molecule is missing or invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\naddress = get_address(mol)  # Returns something like \"0x1a2b3c4d\"\n\nNotes\n\nUseful for debugging and tracking molecule objects\nEach molecule instance has a unique memory address\nAddresses change between different program runs\n\n\n\n\n\n","category":"function"},{"location":"api/descriptors/#Examples-2","page":"Molecular Descriptors","title":"Examples","text":"","category":"section"},{"location":"api/descriptors/#Molecular-Connectivity-Analysis","page":"Molecular Descriptors","title":"Molecular Connectivity Analysis","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"using MoleculeFlow\n\n# Analyze molecular connectivity for drug-like molecules\ncompounds = [\n    mol_from_smiles(\"CC(=O)OC1=CC=CC=C1C(=O)O\"),  # Aspirin\n    mol_from_smiles(\"CCO\"),                         # Ethanol\n    mol_from_smiles(\"c1ccc2c(c1)nnnc2N\")           # Triazole compound\n]\n\nfor (i, mol) in enumerate(compounds)\n    println(\"Compound $i:\")\n    println(\"Chi0n: \", chi0n(mol))\n    println(\"Chi1v: \", chi1v(mol))\n    println(\"Kappa2: \", kappa2(mol))\n    println(\"Max E-state: \", max_e_state_index(mol))\n    println(\"Carbons: \", num_carbons(mol))\n    println(\"Nitrogens: \", num_nitrogens(mol))\n    println(\"Halogens: \", num_halogens(mol))\n    println()\nend","category":"page"},{"location":"api/descriptors/#Working-with-Multiple-Molecules","page":"Molecular Descriptors","title":"Working with Multiple Molecules","text":"","category":"section"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"Most descriptor functions in MoleculeFlow can accept vectors of molecules directly for efficient batch processing:","category":"page"},{"location":"api/descriptors/","page":"Molecular Descriptors","title":"Molecular Descriptors","text":"# Create a vector of molecules\nmolecules = [mol_from_smiles(smi) for smi in [\"CCO\", \"c1ccccc1\", \"CC(=O)N\", \"CCCl\"]]\n\n# Descriptor functions accept vectors directly\nmw_values = molecular_weight(molecules)\nlogp_values = logp(molecules)\nchi_values = chi1v(molecules)\ncarbon_counts = num_carbons(molecules)\n\nprintln(\"Molecular weights: \", mw_values)\nprintln(\"LogP values: \", logp_values)\nprintln(\"Chi1v values: \", chi_values)\nprintln(\"Carbon counts: \", carbon_counts)","category":"page"},{"location":"api/operations/#Molecular-Operations","page":"Molecular Operations","title":"Molecular Operations","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Advanced molecular manipulation, editing, and analysis functions.","category":"page"},{"location":"api/operations/#Hydrogen-Manipulation","page":"Molecular Operations","title":"Hydrogen Manipulation","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Functions for adding and removing explicit hydrogens from molecules.","category":"page"},{"location":"api/operations/#Adding-Hydrogens","page":"Molecular Operations","title":"Adding Hydrogens","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.add_hs","page":"Molecular Operations","title":"MoleculeFlow.add_hs","text":"add_hs(mol::Molecule) -> Molecule\n\nAdd explicit hydrogens to a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nMolecule: New molecule with explicit hydrogens added\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nmol_with_hs = add_hs(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Removing-Hydrogens","page":"Molecular Operations","title":"Removing Hydrogens","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.remove_hs","page":"Molecular Operations","title":"MoleculeFlow.remove_hs","text":"remove_hs(mol::Molecule) -> Molecule\n\nRemove explicit hydrogens from a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nMolecule: New molecule with explicit hydrogens removed\n\nExample\n\nmol_with_hs = add_hs(mol_from_smiles(\"CCO\"))\nmol_no_hs = remove_hs(mol_with_hs)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Extended-File-I/O","page":"Molecular Operations","title":"Extended File I/O","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Additional file format support beyond basic SMILES and MOL files.","category":"page"},{"location":"api/operations/#PDB-Format-Support","page":"Molecular Operations","title":"PDB Format Support","text":"","category":"section"},{"location":"api/operations/#XYZ-Format-Support","page":"Molecular Operations","title":"XYZ Format Support","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.mol_from_xyz_file","page":"Molecular Operations","title":"MoleculeFlow.mol_from_xyz_file","text":"mol_from_xyz_file(filename::String) -> Molecule\n\nRead a molecule from an XYZ file.\n\nXYZ is a simple file format for storing molecular coordinates. The format typically contains the number of atoms, an optional comment line, and atom coordinates.\n\nArguments\n\nfilename: Path to the XYZ file\n\nReturns\n\nMolecule: The parsed molecule object\nReturns invalid molecule if parsing fails\n\nExamples\n\nmol = mol_from_xyz_file(\"molecule.xyz\")\nif mol.valid\n    println(\"Successfully loaded molecule with \", heavy_atom_count(mol), \" heavy atoms\")\nend\n\nNotes\n\nXYZ files contain only 3D coordinates, no bond information\nRDKit may infer bonds based on interatomic distances\nNot all XYZ files will produce chemically meaningful molecules\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#MoleculeFlow.mol_from_xyz_block","page":"Molecular Operations","title":"MoleculeFlow.mol_from_xyz_block","text":"mol_from_xyz_block(xyz_block::String) -> Molecule\n\nParse a molecule from an XYZ format string.\n\nArguments\n\nxyz_block: XYZ format string containing atom coordinates\n\nReturns\n\nMolecule: The parsed molecule object\nReturns invalid molecule if parsing fails\n\nExamples\n\nxyz_data = \"\"\"3\nEthanol molecule\nC    0.000    0.000    0.000\nC    1.520    0.000    0.000\nO    2.080    1.100    0.000\"\"\"\nmol = mol_from_xyz_block(xyz_data)\n\nNotes\n\nFirst line: number of atoms\nSecond line: comment (molecule name/description)\nFollowing lines: element symbol and x, y, z coordinates\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#MoleculeFlow.mol_to_xyz_block","page":"Molecular Operations","title":"MoleculeFlow.mol_to_xyz_block","text":"mol_to_xyz_block(mol::Molecule) -> String\n\nConvert a molecule to XYZ format string.\n\nExports the 3D coordinates of the molecule in XYZ format. The molecule must have 3D coordinates assigned for this to work properly.\n\nArguments\n\nmol: Molecule object with 3D coordinates\n\nReturns\n\nString: XYZ format representation\nEmpty string if conversion fails or molecule has no 3D coordinates\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\n# Generate 3D coordinates first\nconformers = generate_3d_conformers(mol, 1)\nif !isempty(conformers)\n    mol_3d = conformers[1].molecule\n    xyz_string = mol_to_xyz_block(mol_3d)\n    println(xyz_string)\nend\n\nNotes\n\nRequires 3D coordinates to be present in the molecule\nOnly exports heavy atoms (no hydrogens unless explicit)\nBond information is lost in XYZ format\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#MOL2-Format-Support","page":"Molecular Operations","title":"MOL2 Format Support","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.mol_from_mol2_file","page":"Molecular Operations","title":"MoleculeFlow.mol_from_mol2_file","text":"mol_from_mol2_file(filename::String) -> Molecule\n\nRead a molecule from a MOL2 file.\n\nMOL2 (Sybyl format) is a comprehensive molecular file format that includes atoms, bonds, and additional molecular information like partial charges.\n\nArguments\n\nfilename: Path to the MOL2 file\n\nReturns\n\nMolecule: The parsed molecule object\nReturns invalid molecule if parsing fails\n\nExamples\n\nmol = mol_from_mol2_file(\"ligand.mol2\")\nif mol.valid\n    println(\"Loaded molecule: \", mol_to_smiles(mol))\n    println(\"Molecular weight: \", molecular_weight(mol))\nend\n\nNotes\n\nMOL2 format preserves bond orders and formal charges\nMay contain multiple molecules (only first one is loaded)\nPartial charges are preserved if present in the file\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#MoleculeFlow.mol_from_mol2_block","page":"Molecular Operations","title":"MoleculeFlow.mol_from_mol2_block","text":"mol_from_mol2_block(mol2_block::String) -> Molecule\n\nParse a molecule from a MOL2 format string.\n\nArguments\n\nmol2_block: MOL2 format string\n\nReturns\n\nMolecule: The parsed molecule object\nReturns invalid molecule if parsing fails\n\nExamples\n\nmol2_data = \"\"\"@<TRIPOS>MOLECULE\nethanol\n3 2 0 0 0\nSMALL\nNO_CHARGES\n\n@<TRIPOS>ATOM\n1 C1 0.0000 0.0000 0.0000 C.3 1 RES1 0.0000\n2 C2 1.5200 0.0000 0.0000 C.3 1 RES1 0.0000\n3 O1 2.0800 1.1000 0.0000 O.3 1 RES1 0.0000\n\n@<TRIPOS>BOND\n1 1 2 1\n2 2 3 1\n\"\"\"\nmol = mol_from_mol2_block(mol2_data)\n\nNotes\n\nMOL2 format uses TRIPOS record types\nSupports various atom and bond types\nMay include substructure and partial charge information\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Enhanced-Conversions","page":"Molecular Operations","title":"Enhanced Conversions","text":"","category":"section"},{"location":"api/operations/#Molecular-Editing","page":"Molecular Operations","title":"Molecular Editing","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Functions for modifying molecular structures programmatically.","category":"page"},{"location":"api/operations/#Combining-Molecules","page":"Molecular Operations","title":"Combining Molecules","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.combine_mols","page":"Molecular Operations","title":"MoleculeFlow.combine_mols","text":"combine_mols(mol1::Molecule, mol2::Molecule) -> Molecule\n\nCombine two molecules into a single molecule.\n\nArguments\n\nmol1::Molecule: First molecule\nmol2::Molecule: Second molecule\n\nReturns\n\nMolecule: Combined molecule\n\nExample\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\ncombined = combine_mols(mol1, mol2)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Substructure-Modifications","page":"Molecular Operations","title":"Substructure Modifications","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.delete_substructs","page":"Molecular Operations","title":"MoleculeFlow.delete_substructs","text":"delete_substructs(mol::Molecule, query::String) -> Molecule\n\nDelete substructures matching a SMARTS pattern from a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\nquery::String: SMARTS pattern to match and delete\n\nReturns\n\nMolecule: Molecule with matching substructures removed\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\n# Remove alcohol groups\nmol_modified = delete_substructs(mol, \"[OH]\")\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#MoleculeFlow.replace_substructs","page":"Molecular Operations","title":"MoleculeFlow.replace_substructs","text":"replace_substructs(mol::Molecule, query::String, replacement::String) -> Vector{Molecule}\n\nReplace substructures matching a SMARTS pattern with a replacement structure.\n\nArguments\n\nmol::Molecule: Input molecule\nquery::String: SMARTS pattern to match\nreplacement::String: SMILES string for replacement\n\nReturns\n\nVector{Molecule}: Vector of molecules with replacements made\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\n# Replace alcohol with amine\nreplacements = replace_substructs(mol, \"[OH]\", \"N\")\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Stereochemistry-Operations","page":"Molecular Operations","title":"Stereochemistry Operations","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Functions for analyzing and manipulating molecular stereochemistry.","category":"page"},{"location":"api/operations/#Stereochemistry-Assignment","page":"Molecular Operations","title":"Stereochemistry Assignment","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.assign_stereochemistry!","page":"Molecular Operations","title":"MoleculeFlow.assign_stereochemistry!","text":"assign_stereochemistry!(mol::Molecule; clean_it::Bool=true, force::Bool=false) -> Bool\n\nAssign stereochemistry to a molecule in place.\n\nArguments\n\nmol::Molecule: Input molecule (modified in place)\nclean_it::Bool: Whether to clean up the molecule\nforce::Bool: Whether to force assignment\n\nReturns\n\nBool: Success status\n\nExample\n\nmol = mol_from_smiles(\"C[C@H](O)C\")\nsuccess = assign_stereochemistry!(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Chiral-Center-Analysis","page":"Molecular Operations","title":"Chiral Center Analysis","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.find_chiral_centers","page":"Molecular Operations","title":"MoleculeFlow.find_chiral_centers","text":"find_chiral_centers(mol::Molecule; include_unassigned::Bool=false) -> Vector{Tuple{Int,String}}\n\nFind chiral centers in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\ninclude_unassigned::Bool: Whether to include unassigned chiral centers\n\nReturns\n\nVector{Tuple{Int,String}}: Vector of (atom_index, chirality) tuples\n\nExample\n\nmol = mol_from_smiles(\"C[C@H](O)C\")\nchiral_centers = find_chiral_centers(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Ring-Analysis","page":"Molecular Operations","title":"Ring Analysis","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Functions for analyzing ring systems and molecular topology.","category":"page"},{"location":"api/operations/#Ring-Detection","page":"Molecular Operations","title":"Ring Detection","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.fast_find_rings!","page":"Molecular Operations","title":"MoleculeFlow.fast_find_rings!","text":"fast_find_rings!(mol::Molecule) -> Bool\n\nPerform fast ring finding on a molecule in place.\n\nArguments\n\nmol::Molecule: Input molecule (modified in place)\n\nReturns\n\nBool: Success status\n\nExample\n\nmol = mol_from_smiles(\"c1ccccc1\")\nsuccess = fast_find_rings!(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Atom-Ranking","page":"Molecular Operations","title":"Atom Ranking","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.canonical_atom_ranks","page":"Molecular Operations","title":"MoleculeFlow.canonical_atom_ranks","text":"canonical_atom_ranks(mol::Molecule) -> Vector{Int}\n\nGet canonical ranking of atoms in a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nVector{Int}: Canonical ranks for each atom\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nranks = canonical_atom_ranks(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Pattern-Matching","page":"Molecular Operations","title":"Pattern Matching","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Advanced pattern matching and substructure analysis.","category":"page"},{"location":"api/operations/#SMARTS-Matching","page":"Molecular Operations","title":"SMARTS Matching","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.quick_smarts_match","page":"Molecular Operations","title":"MoleculeFlow.quick_smarts_match","text":"quick_smarts_match(mol::Molecule, smarts::String) -> Bool\n\nQuick check if a molecule matches a SMARTS pattern.\n\nArguments\n\nmol::Molecule: Input molecule\nsmarts::String: SMARTS pattern\n\nReturns\n\nBool: Whether the molecule matches the pattern\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nhas_alcohol = quick_smarts_match(mol, \"[OH]\")\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Fragment-Analysis","page":"Molecular Operations","title":"Fragment Analysis","text":"","category":"section"},{"location":"api/operations/#MoleculeFlow.mol_fragment_to_smarts","page":"Molecular Operations","title":"MoleculeFlow.mol_fragment_to_smarts","text":"mol_fragment_to_smarts(mol::Molecule, atom_indices::Vector{Int}) -> String\n\nConvert a molecular fragment to SMARTS representation.\n\nArguments\n\nmol::Molecule: Input molecule\natom_indices::Vector{Int}: Atom indices to include in fragment (0-based)\n\nReturns\n\nString: SMARTS representation of the fragment\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nsmarts = mol_fragment_to_smarts(mol, [0, 1])  # First two atoms\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Examples","page":"Molecular Operations","title":"Examples","text":"","category":"section"},{"location":"api/operations/#Working-with-Hydrogens","page":"Molecular Operations","title":"Working with Hydrogens","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"using MoleculeFlow\n\n# Start with a simple molecule\nmol = mol_from_smiles(\"CCO\")\nprintln(\"Original: \", mol_to_smiles(mol))\n\n# Add explicit hydrogens\nmol_with_hs = add_hs(mol)\nprintln(\"With H's: \", mol_to_smiles(mol_with_hs))\n\n# Remove explicit hydrogens\nmol_clean = remove_hs(mol_with_hs)\nprintln(\"Clean: \", mol_to_smiles(mol_clean))","category":"page"},{"location":"api/operations/#Molecular-Editing-2","page":"Molecular Operations","title":"Molecular Editing","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Combine two molecules\nethanol = mol_from_smiles(\"CCO\")\npropane = mol_from_smiles(\"CCC\")\ncombined = combine_mols(ethanol, propane)\n\n# Remove alcohol groups\nbenzyl_alcohol = mol_from_smiles(\"c1ccc(CO)cc1\")\nbenzene_derivative = delete_substructs(benzyl_alcohol, \"[OH]\")","category":"page"},{"location":"api/operations/#Pattern-Matching-2","page":"Molecular Operations","title":"Pattern Matching","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Check for functional groups\nmol = mol_from_smiles(\"CCO\")\n\nhas_alcohol = quick_smarts_match(mol, \"[OH]\")  # true\nhas_amine = quick_smarts_match(mol, \"[NH2]\")   # false\nhas_carbon = quick_smarts_match(mol, \"[C]\")    # true","category":"page"},{"location":"api/operations/#Stereochemistry-Analysis","page":"Molecular Operations","title":"Stereochemistry Analysis","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Work with chiral molecules\nchiral_mol = mol_from_smiles(\"C[C@H](O)C\")\n\n# Assign stereochemistry\nassign_stereochemistry!(chiral_mol)\n\n# Find chiral centers\ncenters = find_chiral_centers(chiral_mol)\nfor (atom_idx, chirality) in centers\n    println(\"Atom $atom_idx: $chirality\")\nend","category":"page"},{"location":"api/operations/#Advanced-I/O","page":"Molecular Operations","title":"Advanced I/O","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Generate InChI keys for database storage\nmol = mol_from_smiles(\"CCO\")\ninchi_key = mol_to_inchi_key(mol)\nprintln(\"InChI Key: \", inchi_key)\n\n# Export as MOL block\nmolblock = mol_to_molblock(mol)\nprintln(\"MOL Block:\")\nprintln(molblock)","category":"page"},{"location":"api/operations/#Working-with-3D-Coordinates","page":"Molecular Operations","title":"Working with 3D Coordinates","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Load molecule from XYZ file with 3D coordinates\nmol_3d = mol_from_xyz_file(\"molecule.xyz\")\n\n# Or create XYZ format from existing molecule with 3D coordinates\nmol = mol_from_smiles(\"CCO\")\nconformers = generate_3d_conformers(mol, 1)\nif !isempty(conformers)\n    mol_with_coords = conformers[1].molecule\n    xyz_string = mol_to_xyz_block(mol_with_coords)\n    println(\"XYZ Format:\")\n    println(xyz_string)\nend","category":"page"},{"location":"api/operations/#MOL2-Format-for-Pharmacophore-Modeling","page":"Molecular Operations","title":"MOL2 Format for Pharmacophore Modeling","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"# Load ligand from MOL2 file (preserves charges and atom types)\nligand = mol_from_mol2_file(\"drug_compound.mol2\")\n\nif ligand.valid\n    println(\"Loaded ligand: \", mol_to_smiles(ligand))\n    println(\"Heavy atoms: \", heavy_atom_count(ligand))\n\n    # MOL2 format preserves partial charges for QSAR studies\n    atoms = get_atoms(ligand)\n    for atom in atoms[1:3]  # Show first 3 atoms\n        println(\"Atom \", get_symbol(atom), \" charge: \", get_formal_charge(atom))\n    end\nend","category":"page"},{"location":"api/operations/#Notes","page":"Molecular Operations","title":"Notes","text":"","category":"section"},{"location":"api/operations/","page":"Molecular Operations","title":"Molecular Operations","text":"Many functions modify molecules in-place (indicated by ! suffix) for performance\nFunctions return false or empty results when operations fail\nInvalid molecules are handled gracefully without throwing exceptions\nAll new functions integrate seamlessly with existing MoleculeFlow.jl workflows","category":"page"},{"location":"api/io/#Basic-I/O-Operations","page":"Basic I/O","title":"Basic I/O Operations","text":"","category":"section"},{"location":"api/io/","page":"Basic I/O","title":"Basic I/O","text":"Functions for reading and writing molecular structures.","category":"page"},{"location":"api/io/#Reading-Molecules","page":"Basic I/O","title":"Reading Molecules","text":"","category":"section"},{"location":"api/io/#Molecule-from-SMILES","page":"Basic I/O","title":"Molecule from SMILES","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_from_smiles","page":"Basic I/O","title":"MoleculeFlow.mol_from_smiles","text":"mol_from_smiles(smiles::String) -> Molecule\n\nConvert a SMILES string to a Molecule object.\n\nArguments\n\nsmiles::String: A valid SMILES (Simplified Molecular Input Line Entry System) string\n\nReturns\n\nMolecule: A Molecule object. Check mol.valid to see if parsing was successful.\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nif mol.valid\n    println(\"Successfully parsed molecule\")\nend\n\nNotes\n\nInvalid SMILES strings will return a Molecule with valid=false\nImportant: For SMILES containing backslashes, use raw\"...\" strings to avoid Julia's escape sequence parsing, or double the backslashes \\\n\n\n\n\n\nmol_from_smiles(smiles_list::Vector{String}) -> Vector{Molecule}\n\nConvert a vector of SMILES strings to a vector of Molecule objects.\n\nArguments\n\nsmiles_list::Vector{String}: Vector of SMILES strings\n\nReturns\n\nVector{Molecule}: Vector of Molecule objects\n\nExamples\n\nsmiles = [\"CCO\", \"c1ccccc1\", \"CC(=O)O\"]\nmols = mol_from_smiles(smiles)\nvalid_mols = filter(m -> m.valid, mols)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Molecule-from-MOL-Block","page":"Basic I/O","title":"Molecule from MOL Block","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_from_molblock","page":"Basic I/O","title":"MoleculeFlow.mol_from_molblock","text":"mol_from_molblock(molblock::String) -> Molecule\n\nConvert a MOL block string (MDL format) to a Molecule object.\n\nArguments\n\nmolblock::String: A valid MOL block string in MDL format\n\nReturns\n\nMolecule: A Molecule object. Check mol.valid to see if parsing was successful.\n\nExamples\n\nmolblock = \"\"\"\n\n  RDKit          2D\n\n  2  1  0  0  0  0  0  0  0  0999 V2000\n    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0\nM  END\n\"\"\"\nmol = mol_from_molblock(molblock)\n\nNotes\n\nInvalid MOL blocks will return a Molecule with valid=false\nCommonly used for reading individual molecular structures from files\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Molecule-from-InChI","page":"Basic I/O","title":"Molecule from InChI","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_from_inchi","page":"Basic I/O","title":"MoleculeFlow.mol_from_inchi","text":"mol_from_inchi(inchi::String) -> Molecule\n\nConvert an InChI string to a Molecule object.\n\nArguments\n\ninchi::String: A valid InChI (International Chemical Identifier) string\n\nReturns\n\nMolecule: A Molecule object. Check mol.valid to see if parsing was successful.\n\nExamples\n\nmol = mol_from_inchi(\"InChI=1S/C2H6/c1-2/h1-2H3\")  # Ethane\nif mol.valid\n    println(\"Successfully parsed molecule\")\nend\n\nmol2 = mol_from_inchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\")  # Benzene\n\nNotes\n\nInvalid InChI strings will return a Molecule with valid=false\nThe original InChI string is stored in the molecule's props as :InChI\n\n\n\n\n\nmol_from_inchi(inchi_list::Vector{String}) -> Vector{Molecule}\n\nConvert a vector of InChI strings to a vector of Molecule objects.\n\nArguments\n\ninchi_list::Vector{String}: Vector of InChI strings\n\nReturns\n\nVector{Molecule}: Vector of Molecule objects\n\nExamples\n\ninchis = [\n    \"InChI=1S/C2H6/c1-2/h1-2H3\",     # Ethane\n    \"InChI=1S/C3H8/c1-3-2/h3H2,1-2H3\",  # Propane\n    \"invalid_inchi\",                  # Invalid\n    \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\"  # Benzene\n]\nmols = mol_from_inchi(inchis)\nvalid_mols = filter(m -> m.valid, mols)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#PDB-Format-Support","page":"Basic I/O","title":"PDB Format Support","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_from_pdb_block","page":"Basic I/O","title":"MoleculeFlow.mol_from_pdb_block","text":"mol_from_pdb_block(pdb_block::String) -> Molecule\n\nCreate a molecule from a PDB block string.\n\nArguments\n\npdb_block::String: PDB format string\n\nReturns\n\nMolecule: Parsed molecule or invalid molecule if parsing fails\n\nExample\n\npdb_data = \"ATOM      1  C   MOL A   1      20.154  21.875  21.235  1.00 10.00           C\"\nmol = mol_from_pdb_block(pdb_data)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#MoleculeFlow.mol_from_pdb_file","page":"Basic I/O","title":"MoleculeFlow.mol_from_pdb_file","text":"mol_from_pdb_file(filename::String) -> Molecule\n\nCreate a molecule from a PDB file.\n\nArguments\n\nfilename::String: Path to PDB file\n\nReturns\n\nMolecule: Parsed molecule or invalid molecule if parsing fails\n\nExample\n\nmol = mol_from_pdb_file(\"protein.pdb\")\n\n\n\n\n\n","category":"function"},{"location":"api/io/#MoleculeFlow.mol_to_pdb_block","page":"Basic I/O","title":"MoleculeFlow.mol_to_pdb_block","text":"mol_to_pdb_block(mol::Molecule; confId::Int=-1) -> String\n\nConvert a molecule to PDB block format.\n\nArguments\n\nmol::Molecule: Input molecule\nconfId::Int: Conformer ID to use (-1 for default)\n\nReturns\n\nString: PDB format string or empty string if conversion fails\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\npdb_block = mol_to_pdb_block(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Read-SDF","page":"Basic I/O","title":"Read SDF","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.read_sdf","page":"Basic I/O","title":"MoleculeFlow.read_sdf","text":"read_sdf(filename::String; max_mols::Union{Int,Nothing}=nothing,\n        include_props::Bool=true, sanitize::Bool=true) -> Vector{Molecule}\n\nRead molecules from an SDF (Structure Data File) format file.\n\nArguments\n\nfilename::String: Path to the SDF file\nmax_mols::Union{Int,Nothing}=nothing: Maximum number of molecules to read (nothing for all)\ninclude_props::Bool=true: Whether to include SDF properties in molecule props\nsanitize::Bool=true: Whether to sanitize molecules during reading\n\nReturns\n\nVector{Molecule}: Vector of Molecule objects read from the SDF file\n\nExamples\n\n# Read all molecules from an SDF file\nmolecules = read_sdf(\"compounds.sdf\")\nvalid_mols = filter(mol -> mol.valid, molecules)\n\n# Read only first 100 molecules\nmolecules = read_sdf(\"large_database.sdf\", max_mols=100)\n\n# Read without properties for faster parsing\nmolecules = read_sdf(\"structures_only.sdf\", include_props=false)\n\nNotes\n\nInvalid molecules in the SDF will be included with valid=false\nSDF properties are stored in the props field of each molecule\nLarge SDF files are processed efficiently using RDKit's supplier mechanism\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Read-SDF-Lazy","page":"Basic I/O","title":"Read SDF Lazy","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.read_sdf_lazy","page":"Basic I/O","title":"MoleculeFlow.read_sdf_lazy","text":"read_sdf_lazy(filename::String; sanitize::Bool=true) -> Function\n\nCreate a lazy iterator for reading molecules from an SDF file one at a time.\n\nArguments\n\nfilename::String: Path to the SDF file\nsanitize::Bool=true: Whether to sanitize molecules during reading\n\nReturns\n\nFunction: A function that returns the next molecule when called, or nothing when done\n\nExamples\n\n# Process large SDF file without loading all molecules into memory\nnext_mol = read_sdf_lazy(\"huge_database.sdf\")\n\nwhile true\n    mol = next_mol()\n    if mol === nothing\n        break  # End of file\n    end\n\n    if mol.valid\n        # Process the molecule\n        println(\"Processing: $(mol_to_smiles(mol))\")\n    end\nend\n\nNotes\n\nMemory efficient for large SDF files\nReturns nothing when no more molecules are available\nEach molecule includes SDF properties in its props field\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Molecule-to-SMILES","page":"Basic I/O","title":"Molecule to SMILES","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_to_smiles","page":"Basic I/O","title":"MoleculeFlow.mol_to_smiles","text":"mol_to_smiles(mol::Union{Molecule,Missing}) -> Union{String,Missing}\n\nConvert a Molecule object to a SMILES string.\n\nArguments\n\nmol::Union{Molecule,Missing}: A Molecule object or missing\n\nReturns\n\nUnion{String,Missing}: SMILES string, or missing if the molecule is invalid or missing\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nsmiles = mol_to_smiles(mol)  # \"CCO\"\n\n# Handles missing values gracefully\nsmiles = mol_to_smiles(missing)  # missing\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Molecule-to-InChI","page":"Basic I/O","title":"Molecule to InChI","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_to_inchi","page":"Basic I/O","title":"MoleculeFlow.mol_to_inchi","text":"mol_to_inchi(mol::Union{Molecule,Missing}) -> Union{String,Missing}\n\nConvert a Molecule object to an InChI (International Chemical Identifier) string.\n\nArguments\n\nmol::Union{Molecule,Missing}: A Molecule object or missing\n\nReturns\n\nUnion{String,Missing}: InChI string, or missing if the molecule is invalid or missing\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\ninchi = mol_to_inchi(mol)  # \"InChI=1S/C2H6O/c1-2-3/h3H,2H2,1H3\"\n\nNotes\n\nInChI provides a unique identifier for chemical structures\nMore verbose than SMILES but provides standardized representation\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Enhanced-Molecular-Conversions","page":"Basic I/O","title":"Enhanced Molecular Conversions","text":"","category":"section"},{"location":"api/io/#MoleculeFlow.mol_to_inchi_key","page":"Basic I/O","title":"MoleculeFlow.mol_to_inchi_key","text":"mol_to_inchi_key(mol::Molecule) -> String\n\nGenerate InChI key for a molecule.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nString: InChI key or empty string if generation fails\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\ninchi_key = mol_to_inchi_key(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#MoleculeFlow.mol_to_molblock","page":"Basic I/O","title":"MoleculeFlow.mol_to_molblock","text":"mol_to_molblock(mol::Molecule) -> String\n\nConvert a molecule to MOL block format.\n\nArguments\n\nmol::Molecule: Input molecule\n\nReturns\n\nString: MOL block string or empty string if conversion fails\n\nExample\n\nmol = mol_from_smiles(\"CCO\")\nmolblock = mol_to_molblock(mol)\n\n\n\n\n\n","category":"function"},{"location":"examples/#Practical-Examples","page":"Practical Examples","title":"Practical Examples","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"Here are comprehensive practical examples of using MoleculeFlow.jl for molecular analysis, manipulation, and visualization.","category":"page"},{"location":"examples/#Basic-Molecule-Management","page":"Practical Examples","title":"Basic Molecule Management","text":"","category":"section"},{"location":"examples/#Creating-and-Validating-Molecules","page":"Practical Examples","title":"Creating and Validating Molecules","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"using MoleculeFlow\n\n# Create molecules from SMILES\nethanol = mol_from_smiles(\"CCO\")\nbenzene = mol_from_smiles(\"c1ccccc1\")\ninvalid_mol = mol_from_smiles(\"invalid_smiles\")\n\n# Check validity\nprintln(\"Ethanol valid: $(ethanol.valid)\")\nprintln(\"Benzene valid: $(benzene.valid)\")\nprintln(\"Invalid mol valid: $(invalid_mol.valid)\")\n\n# Access molecule source (original SMILES)\nprintln(\"Ethanol source: $(ethanol.source)\")\n\n# Batch creation from SMILES list\nsmiles_list = [\"CCO\", \"CCC\", \"c1ccccc1\", \"CC(=O)O\"]\nmolecules = mol_from_smiles(smiles_list)\nvalid_molecules = filter(mol -> mol.valid, molecules)","category":"page"},{"location":"examples/#Converting-Molecules-Back-to-SMILES","page":"Practical Examples","title":"Converting Molecules Back to SMILES","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Convert single molecule\nethanol_smiles = mol_to_smiles(ethanol)\nprintln(\"Ethanol SMILES: $ethanol_smiles\")\n\n# Convert multiple molecules\noutput_smiles = mol_to_smiles(molecules)\nprintln(\"Output SMILES: $output_smiles\")\n\n# Generate InChI representation\nethanol_inchi = mol_to_inchi(ethanol)\nprintln(\"Ethanol InChI: $ethanol_inchi\")","category":"page"},{"location":"examples/#Reading-from-SDF-Files","page":"Practical Examples","title":"Reading from SDF Files","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Read all molecules from an SDF file\n# Note: This example assumes you have an SDF file\ntry\n    molecules = read_sdf(\"compounds.sdf\")\n    println(\"Read $(length(molecules)) molecules from SDF\")\n\n    # Filter valid molecules\n    valid_molecules = filter(mol -> mol.valid, molecules)\n    println(\"$(length(valid_molecules)) valid molecules\")\n\n    # Access SDF properties\n    for mol in valid_molecules[1:min(3, length(valid_molecules))]\n        println(\"Molecule: $(mol_to_smiles(mol))\")\n        println(\"  SDF Index: $(mol.props[:sdf_index])\")\n        println(\"  Source File: $(mol.props[:source_file])\")\n\n        # Display other SDF properties\n        for (key, value) in mol.props\n            if key ∉ [:sdf_index, :source_file]\n                println(\"  $key: $value\")\n            end\n        end\n        println()\n    end\n\ncatch e\n    println(\"SDF file not found or error reading: $e\")\nend\n\n# Read only first 100 molecules for large files\ntry\n    molecules = read_sdf(\"large_database.sdf\", max_mols=100)\n    println(\"Read first 100 molecules from large SDF\")\ncatch e\n    println(\"Large SDF file not found: $e\")\nend\n\n# Memory-efficient reading for huge files\ntry\n    next_mol = read_sdf_lazy(\"huge_database.sdf\")\n    mol_count = 0\n\n    while mol_count < 10  # Process first 10 molecules\n        mol = next_mol()\n        if mol === nothing\n            break  # End of file\n        end\n\n        mol_count += 1\n        if mol.valid\n            smiles = mol_to_smiles(mol)\n            println(\"Molecule $mol_count: $smiles\")\n        end\n    end\ncatch e\n    println(\"Huge SDF file not found: $e\")\nend","category":"page"},{"location":"examples/#Reading-MOL-Blocks","page":"Practical Examples","title":"Reading MOL Blocks","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Example MOL block (ethane)\nmolblock = \"\"\"\n\n  RDKit          2D\n\n  2  1  0  0  0  0  0  0  0  0999 V2000\n    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0\nM  END\n\"\"\"\n\nmol = mol_from_molblock(molblock)\nif mol.valid\n    println(\"Successfully parsed MOL block\")\n    println(\"SMILES: $(mol_to_smiles(mol))\")\nelse\n    println(\"Failed to parse MOL block\")\nend","category":"page"},{"location":"examples/#Working-with-Atoms","page":"Practical Examples","title":"Working with Atoms","text":"","category":"section"},{"location":"examples/#Basic-Atom-Access-and-Properties","page":"Practical Examples","title":"Basic Atom Access and Properties","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Get all atoms from a molecule\ncaffeine = mol_from_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\natoms = get_atoms(caffeine)\nprintln(\"Caffeine has $(length(atoms)) atoms\")\n\n# Get specific atom by index (1-based)\nfirst_atom = get_atom(caffeine, 1)\nprintln(\"First atom symbol: $(get_symbol(first_atom))\")\nprintln(\"First atom atomic number: $(get_atomic_number(first_atom))\")\n\n# Iterate over all atoms\nprintln(\"\\nAll atoms in caffeine:\")\nfor (i, atom) in enumerate(atoms)\n    symbol = get_symbol(atom)\n    atomic_num = get_atomic_number(atom)\n    degree = get_degree(atom)\n    println(\"Atom $i: $symbol (Z=$atomic_num, degree=$degree)\")\nend","category":"page"},{"location":"examples/#Advanced-Atom-Properties","page":"Practical Examples","title":"Advanced Atom Properties","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Get detailed atom properties\nfor (i, atom) in enumerate(atoms[1:5])  # First 5 atoms\n    symbol = get_symbol(atom)\n    degree = get_degree(atom)\n    valence = get_valence(atom)\n    formal_charge = get_formal_charge(atom)\n    hybridization = get_hybridization(atom)\n    is_aromatic_atom = is_aromatic(atom)\n    is_in_ring_atom = is_in_ring(atom)\n\n    println(\"Atom $i ($symbol):\")\n    println(\"Degree: $degree, Valence: $valence\")\n    println(\"Formal charge: $formal_charge\")\n    println(\"Hybridization: $hybridization\")\n    println(\"Aromatic: $is_aromatic_atom, In ring: $is_in_ring_atom\")\n    println()\nend","category":"page"},{"location":"examples/#Atom-Neighbors-and-Connectivity","page":"Practical Examples","title":"Atom Neighbors and Connectivity","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Get neighbors of specific atoms\nprintln(\"Analyzing atom connectivity:\")\nfor i in 1:min(5, length(atoms))\n    neighbors = get_neighbors(caffeine, i)\n    neighbor_symbols = [get_symbol(get_atom(caffeine, j)) for j in neighbors]\n\n    atom_symbol = get_symbol(get_atom(caffeine, i))\n    println(\"Atom $i ($atom_symbol) connected to: $(join(neighbor_symbols, \", \"))\")\nend\n\n# Get bonds involving specific atoms\nprintln(\"\\nBonds from first atom:\")\nbonds_from_atom1 = get_bonds_from_atom(caffeine, 1)\nfor (i, bond) in enumerate(bonds_from_atom1)\n    bond_type = get_bond_type(bond)\n    begin_atom = get_begin_atom_idx(bond)\n    end_atom = get_end_atom_idx(bond)\n    println(\"Bond $i: Atom $begin_atom - Atom $end_atom ($bond_type)\")\nend","category":"page"},{"location":"examples/#Gasteiger-Partial-Charges","page":"Practical Examples","title":"Gasteiger Partial Charges","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"charged_mol = mol_from_smiles(\"[NH3+]CCO\")  # Protonated ethylamine\ncompute_gasteiger_charges!(charged_mol)\n\natoms = get_atoms(charged_mol)\nprintln(\"Gasteiger partial charges:\")\nfor (i, atom) in enumerate(atoms)\n    symbol = get_symbol(atom)\n    charge = get_gasteiger_charge(atom)\n    println(\"Atom $i ($symbol): $charge\")\nend","category":"page"},{"location":"examples/#Working-with-Bonds","page":"Practical Examples","title":"Working with Bonds","text":"","category":"section"},{"location":"examples/#Basic-Bond-Analysis","page":"Practical Examples","title":"Basic Bond Analysis","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"molecule = mol_from_smiles(\"CC=C(C)C#N\")\n\nprintln(\"Bond analysis for CC=C(C)C#N:\")\natoms = get_atoms(molecule)\nfor i in eachindex(atoms)\n    bonds = get_bonds_from_atom(molecule, i)\n    if !isempty(bonds)\n        atom_symbol = get_symbol(get_atom(molecule, i))\n        println(\"\\nAtom $i ($atom_symbol) bonds:\")\n\n        for bond in bonds\n            bond_type = get_bond_type(bond)\n            begin_idx = get_begin_atom_idx(bond)\n            end_idx = get_end_atom_idx(bond)\n            is_aromatic_bond = is_aromatic(bond)\n            is_in_ring_bond = is_in_ring(bond)\n\n            other_atom_idx = begin_idx == i ? end_idx : begin_idx\n            other_symbol = get_symbol(get_atom(molecule, other_atom_idx))\n\n            println(\"to Atom $other_atom_idx ($other_symbol): $bond_type\" *\n                   (is_aromatic_bond ? \" (aromatic)\" : \"\") *\n                   (is_in_ring_bond ? \" (in ring)\" : \"\"))\n        end\n    end\nend","category":"page"},{"location":"examples/#Bond-Type-Classification","page":"Practical Examples","title":"Bond Type Classification","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"complex_mol = mol_from_smiles(\"c1ccc2c(c1)ccc(=O)c2=O\")  # Naphthoquinone\n\nsingle_bonds = 0\ndouble_bonds = 0\naromatic_bonds = 0\nring_bonds = 0\n\natoms = get_atoms(complex_mol)\nprocessed_bonds = Set()  # To avoid counting bonds twice\n\nfor i in eachindex(atoms)\n    bonds = get_bonds_from_atom(complex_mol, i)\n    for bond in bonds\n        begin_idx = get_begin_atom_idx(bond)\n        end_idx = get_end_atom_idx(bond)\n        bond_key = (min(begin_idx, end_idx), max(begin_idx, end_idx))\n\n        if bond_key ∉ processed_bonds\n            push!(processed_bonds, bond_key)\n\n            bond_type = get_bond_type(bond)\n            if bond_type == \"SINGLE\"\n                single_bonds += 1\n            elseif bond_type == \"DOUBLE\"\n                double_bonds += 1\n            elseif bond_type == \"AROMATIC\"\n                aromatic_bonds += 1\n            end\n\n            if is_in_ring(bond)\n                ring_bonds += 1\n            end\n        end\n    end\nend\n\nprintln(\"Bond analysis for naphthoquinone:\")\nprintln(\"Single bonds: $single_bonds\")\nprintln(\"Double bonds: $double_bonds\")\nprintln(\"Aromatic bonds: $aromatic_bonds\")\nprintln(\"Ring bonds: $ring_bonds\")","category":"page"},{"location":"examples/#Molecular-Properties-and-Descriptors","page":"Practical Examples","title":"Molecular Properties and Descriptors","text":"","category":"section"},{"location":"examples/#Comprehensive-Property-Analysis","page":"Practical Examples","title":"Comprehensive Property Analysis","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"mol = mol_from_smiles(\"CCO\")\n\nprintln(\"Molecular Properties Analysis:\")\nmw = molecular_weight(mol)\nlogp_val = logp(mol)\ntpsa_val = tpsa(mol)\nhbd = num_hbd(mol)\nhba = num_hba(mol)\nrot_bonds = num_rotatable_bonds(mol)\nrings = num_rings(mol)\nheavy_atoms = heavy_atom_count(mol)","category":"page"},{"location":"examples/#Lipinski's-Rule-of-Five-Analysis","page":"Practical Examples","title":"Lipinski's Rule of Five Analysis","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"function check_lipinski(mol::Molecule)\n    \"\"\"Check if molecule passes Lipinski's Rule of Five\"\"\"\n    if !mol.valid\n        return false, \"Invalid molecule\"\n    end\n\n    mw = molecular_weight(mol)\n    logp_val = logp(mol)\n    hbd = num_hbd(mol)\n    hba = num_hba(mol)\n\n    violations = []\n\n    if mw > 500\n        push!(violations, \"MW > 500 ($(round(mw, digits=1)))\")\n    end\n    if logp_val > 5\n        push!(violations, \"LogP > 5 ($(round(logp_val, digits=1)))\")\n    end\n    if hbd > 5\n        push!(violations, \"HBD > 5 ($hbd)\")\n    end\n    if hba > 10\n        push!(violations, \"HBA > 10 ($hba)\")\n    end\n\n    passes = isempty(violations)\n    message = passes ? \"Passes Lipinski's Rule of Five\" : \"Violations: \" * join(violations, \", \")\n\n    return passes, message\nend\n\n# Test Lipinski's rule on drug-like molecules\ndrug_smiles = [\n    (\"Aspirin\", \"CC(=O)Oc1ccccc1C(=O)O\"),\n    (\"Ibuprofen\", \"CC(C)Cc1ccc(cc1)C(C)C(=O)O\"),\n    (\"Atorvastatin\", \"CC(C)c1c(C(=O)Nc2ccccc2F)c(-c2ccccc2)c(-c2ccc(F)cc2)n1C[C@H](O)C[C@H](O)CC(=O)O\"),\n    (\"Caffeine\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\n]\n\nprintln(\"\\nLipinski's Rule of Five Analysis:\")\nfor (name, smiles) in drug_smiles\n    mol = mol_from_smiles(smiles)\n    passes, message = check_lipinski(mol)\n    status = passes ? \"PASS\" : \"FAIL\"\n    println(\"$name: $status\")\n    println(\"$message\")\n    println()\nend","category":"page"},{"location":"examples/#Substructure-Analysis","page":"Practical Examples","title":"Substructure Analysis","text":"","category":"section"},{"location":"examples/#Finding-Functional-Groups","page":"Practical Examples","title":"Finding Functional Groups","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"mol = mol_from_smiles(\"C=CC(=O)N1CCC[C@H](C1)N2C3=NC=NC(=C3C(=N2)C4=CC=C(C=C4)OC5=CC=CC=C5)N\") # Ibrutinib\n\nfunctional_groups_to_check = [\n    :alcohol, :carboxylic_acid, :amide, :amine_primary,\n    :benzene, :phenol, :ketone, :aldehyde\n]\n\nprintln(\"Functional Group Analysis:\")\nfor fg in functional_groups_to_check\n    has_fg = has_functional_group(mol, fg)\n    print(fg, \": \" ,has_fg, \"\\n\")\nend","category":"page"},{"location":"examples/#Custom-Substructure-Searches","page":"Practical Examples","title":"Custom Substructure Searches","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Define custom SMARTS patterns\ncustom_patterns = [\n    (\"Hydroxyl\", \"[OH]\"),\n    (\"Carbonyl\", \"C=O\"),\n    (\"Aromatic Ring\", \"c1ccccc1\"),\n    (\"Primary Amine\", \"[NH2]\"),\n    (\"Ester\", \"[CX3](=O)[OX2H0]\"),\n    (\"Benzyl\", \"c1ccccc1[CH2]\"),\n    (\"Trifluoromethyl\", \"C(F)(F)F\")\n]\n\ntest_mol = mol_from_smiles(\"CC(=O)Oc1ccc(cc1)C(=O)O\")  # Aspirin\n\nprintln(\"Custom substructure analysis for Aspirin:\")\nfor (name, pattern) in custom_patterns\n    matches = get_substructure_matches(test_mol, pattern)\n    if !isempty(matches)\n        println(\"$name: Found $(length(matches)) match(es)\")\n        for (i, match) in enumerate(matches)\n            println(\"Match $i: atoms $(join(match, \", \"))\")\n        end\n    else\n        println(\"$name: Not found\")\n    end\nend","category":"page"},{"location":"examples/#Similarity-and-Fingerprints","page":"Practical Examples","title":"Similarity and Fingerprints","text":"","category":"section"},{"location":"examples/#Comprehensive-Similarity-Analysis","page":"Practical Examples","title":"Comprehensive Similarity Analysis","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Calculate multiple similarity metrics\nmol1 = mol_from_smiles(\"CCO\")  # Ethanol\nmol2 = mol_from_smiles(\"CCC\")  # Propane\nmol3 = mol_from_smiles(\"CCCO\") # Propanol\n\nmolecules = [(\"Ethanol\", mol1), (\"Propane\", mol2), (\"Propanol\", mol3)]\n\n# Calculate different fingerprint types\nfingerprint_types = [:morgan, :rdk, :maccs]\n\nprintln(\"Similarity Analysis:\")\nfor fp_type in fingerprint_types\n    println(\"\\n$fp_type Fingerprints:\")\n\n    # Calculate pairwise similarities\n    for i in eachindex(molecules)\n        for j in (i+1):length(molecules)\n            name1, mol_i = molecules[i]\n            name2, mol_j = molecules[j]\n\n            # Calculate different similarity metrics\n            tanimoto = tanimoto_similarity(mol_i, mol_j, fingerprint_type=fp_type)\n            dice = dice_similarity(mol_i, mol_j, fingerprint_type=fp_type)\n            cosine = cosine_similarity(mol_i, mol_j, fingerprint_type=fp_type)\n\n            println(\"$name1 vs $name2:\")\n            println(\"Tanimoto: $(round(tanimoto, digits=3))\")\n            println(\"Dice: $(round(dice, digits=3))\")\n            println(\"Cosine: $(round(cosine, digits=3))\")\n        end\n    end\nend","category":"page"},{"location":"examples/#Bulk-Similarity-and-Matrix-Calculations","page":"Practical Examples","title":"Bulk Similarity and Matrix Calculations","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Create a dataset of similar molecules\nalcohol_smiles = [\"CCO\", \"CCCO\", \"CC(C)O\", \"CCCCO\", \"CC(C)CO\", \"c1ccc(O)cc1\"]\nalcohol_mols = mol_from_smiles(alcohol_smiles)\nvalid_alcohols = filter(mol -> mol.valid, alcohol_mols)\n\n# Query molecule\nquery = mol_from_smiles(\"CCO\")\n\n# Bulk similarity calculation\nsimilarities = bulk_similarity(query, valid_alcohols)\nprintln(\"Similarities to ethanol:\")\nfor (i, sim) in enumerate(similarities)\n    smiles = mol_to_smiles(valid_alcohols[i])\n    println(\"$smiles: $(round(sim, digits=3))\")\nend\n\n# Similarity matrix\nsim_matrix = similarity_matrix(valid_alcohols[1:4])  # First 4 molecules\nprintln(\"\\nSimilarity Matrix (4x4):\")\nfor i in 1:4\n    row = [round(sim_matrix[i, j], digits=3) for j in 1:4]\n    println(\"$(join(row, \"  \"))\")\nend","category":"page"},{"location":"examples/#Molecular-Visualization","page":"Practical Examples","title":"Molecular Visualization","text":"","category":"section"},{"location":"examples/#Basic-Visualization-Examples","page":"Practical Examples","title":"Basic Visualization Examples","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Create various molecular images\nmolecules_to_draw = [\n    (\"Caffeine\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"),\n    (\"Aspirin\", \"CC(=O)Oc1ccccc1C(=O)O\"),\n    (\"Morphine\", \"CN1CC[C@]23c4c5ccc(O)c4O[C@H]2C(=O)CC[C@@]3([C@H]1C5)\")\n]\n\nfor (name, smiles) in molecules_to_draw\n    mol = mol_from_smiles(smiles)\n    if mol.valid\n        # Generate basic image\n        img = mol_to_image(mol, size=(400, 400))\n\n        # Generate SVG\n        svg = mol_to_svg(mol, size=(400, 400))\n\n        # Save images (if desired)\n        # save_molecule_image(mol, \"$name.svg\")\n\n        println(\"Generated images for $name\")\n    end\nend","category":"page"},{"location":"examples/#Advanced-Visualization-with-Highlighting","page":"Practical Examples","title":"Advanced Visualization with Highlighting","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Highlight functional groups\naspirin = mol_from_smiles(\"CC(=O)Oc1ccccc1C(=O)O\")\n\n# Find and highlight ester group\nester_matches = get_substructure_matches(aspirin, \"[CX3](=O)[OX2H0]\")\nif !isempty(ester_matches)\n    highlighted_img = mol_to_image(aspirin,\n                                  highlight_atoms=ester_matches[1],\n                                  size=(500, 500))\n    println(\"Highlighted ester group in aspirin\")\nend\n\n# Create grid of molecules with legends\nmolecules = [mol_from_smiles(smiles) for (_, smiles) in molecules_to_draw]\nnames = [name for (name, _) in molecules_to_draw]\n\ngrid_img = mols_to_grid_image(molecules,\n                             legends=names,\n                             mols_per_row=2,\n                             sub_img_size=(300, 300))\nprintln(\"Created molecular grid\")\n\n# Functional group highlighting\nacetaminophen = mol_from_smiles(\"CC(=O)Nc1ccc(O)cc1\")\nfg_img = draw_functional_groups(acetaminophen,\n                               functional_groups=[\"[OH]\", \"C=O\", \"[NH]\"],\n                               colors=[\"red\", \"blue\", \"green\"])\nprintln(\"Highlighted functional groups in acetaminophen\")","category":"page"},{"location":"examples/#Dataset-Analysis","page":"Practical Examples","title":"Dataset Analysis","text":"","category":"section"},{"location":"examples/#Processing-Molecular-Datasets","page":"Practical Examples","title":"Processing Molecular Datasets","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Simulate a small molecular dataset\ndataset_smiles = [\n    \"CCO\", \"CCC\", \"CCCO\", \"CC(C)O\", \"CCCCO\",\n    \"c1ccccc1\", \"c1ccc(O)cc1\", \"c1ccc(N)cc1\",\n    \"CC(=O)O\", \"CC(=O)N\", \"CC(=O)c1ccccc1\",\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"\n]\n\n# Create molecules and filter valid ones\nmolecules = mol_from_smiles(dataset_smiles)\nvalid_molecules = filter(mol -> mol.valid, molecules)\n\nprintln(\"Dataset Analysis:\")\nprintln(\"Total molecules: $(length(dataset_smiles))\")\nprintln(\"Valid molecules: $(length(valid_molecules))\")\n\n# Calculate properties for the dataset\nproperties = []\nfor mol in valid_molecules\n    props = (\n        mw = molecular_weight(mol),\n        logp = logp(mol),\n        tpsa = tpsa(mol),\n        hbd = num_hbd(mol),\n        hba = num_hba(mol),\n        rings = num_rings(mol),\n        smiles = mol_to_smiles(mol)\n    )\n    push!(properties, props)\nend\n\nmws = [p.mw for p in properties]\nlogps = [p.logp for p in properties]","category":"page"},{"location":"examples/#Clustering-by-Similarity","page":"Practical Examples","title":"Clustering by Similarity","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Simple clustering based on Tanimoto similarity\nfunction simple_clustering(molecules, threshold=0.7)\n    clusters = []\n    assigned = falses(length(molecules))\n\n    for i in eachindex(molecules)\n        if assigned[i]\n            continue\n        end\n\n        cluster = [i]\n        assigned[i] = true\n\n        for j in (i+1):length(molecules)\n            if assigned[j]\n                continue\n            end\n\n            sim = tanimoto_similarity(molecules[i], molecules[j])\n            if sim >= threshold\n                push!(cluster, j)\n                assigned[j] = true\n            end\n        end\n\n        push!(clusters, cluster)\n    end\n\n    return clusters\nend\n\n# Apply clustering\nclusters = simple_clustering(valid_molecules, 0.5)\nprintln(\"\\nClustering Results (threshold=0.5):\")\nfor (i, cluster) in enumerate(clusters)\n    println(\"Cluster $i ($(length(cluster)) molecules):\")\n    for idx in cluster\n        smiles = mol_to_smiles(valid_molecules[idx])\n        println(\"  $smiles\")\n    end\n    println()\nend","category":"page"},{"location":"examples/#Molecular-Standardization","page":"Practical Examples","title":"Molecular Standardization","text":"","category":"section"},{"location":"examples/#Comprehensive-Standardization-Workflow","page":"Practical Examples","title":"Comprehensive Standardization Workflow","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"messy_molecules = [\n    (\"Salt mixture\", \"CCO.Cl\"),\n    (\"Charged molecule\", \"CC(=O)[O-].[Na+]\"),\n    (\"Tautomer\", \"CC(O)=CC(=O)C\"),\n    (\"Stereochemistry\", \"C[C@H](O)C\")\n]\n\nprintln(\"Molecular Standardization Examples:\")\nfor (name, smiles) in messy_molecules\n    mol = mol_from_smiles(smiles)\n    if mol.valid\n        println(\"\\n$name: $smiles\")\n\n        # Apply different standardization steps\n        stripped = strip_salts(mol)\n        canonical = canonical_tautomer(mol)\n        neutralized = neutralize_charges(mol)\n        normalized = normalize_molecule(mol)\n\n        # Full standardization\n        standardized = standardize_molecule(mol)\n\n        println(\"Original:      $(mol_to_smiles(mol))\")\n        println(\"Salt stripped: $(mol_to_smiles(stripped))\")\n        println(\"Canonical:     $(mol_to_smiles(canonical))\")\n        println(\"Neutralized:   $(mol_to_smiles(neutralized))\")\n        println(\"Normalized:    $(mol_to_smiles(normalized))\")\n        println(\"Standardized:  $(mol_to_smiles(standardized))\")\n    end\nend\n\n# Batch standardization\nbatch_smiles = [\"CCO.Cl\", \"CC(=O)[O-].[Na+]\", \"CC(O)=CC(=O)C\"]\nbatch_mols = mol_from_smiles(batch_smiles)\nstandardized_mols = [standardize_molecule(mol) for mol in batch_mols]\n\nprintln(\"\\nBatch Standardization:\")\nfor (i, (orig, std)) in enumerate(zip(batch_mols, standardized_mols))\n    println(\"$i: $(mol_to_smiles(orig)) → $(mol_to_smiles(std))\")\nend","category":"page"},{"location":"examples/#3D-Conformer-Generation","page":"Practical Examples","title":"3D Conformer Generation","text":"","category":"section"},{"location":"examples/#Generating-and-Analyzing-Conformers","page":"Practical Examples","title":"Generating and Analyzing Conformers","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Generate conformers for a flexible molecule\nflexible_mol = mol_from_smiles(\"CCCCCCCC\")  # Octane\n\n# Generate multiple conformers\nconformers = generate_3d_conformers(flexible_mol, 10, optimize=true)\n\nif !isempty(conformers)\n    println(\"Generated $(length(conformers)) conformers for octane:\")\n\n    for (i, conf_mol) in enumerate(conformers[1:min(5, length(conformers))])  # Show first 5 or fewer\n        conf_result = conf_mol.conformer_result\n        energy = conf_result.energy\n        converged = conf_result.converged ? \"✓\" : \"✗\"\n\n        println(\"Conformer $i: $(round(energy, digits=2)) kcal/mol (converged: $converged)\")\n\n        # Access 3D coordinates\n        coords = conf_mol.molecule.props[:coordinates_3d]\n        println(\"Coordinates shape: $(size(coords))\")\n    end\n\n    # Find lowest energy conformer\n    best_conf = conformers[1]  # Already sorted by energy\n    println(\"\\nBest conformer energy: $(round(best_conf.conformer_result.energy, digits=2)) kcal/mol\")\nend\n\n# 2D coordinate generation\nmol_2d = mol_from_smiles(\"c1ccc2c(c1)ccc(=O)c2=O\")  # Naphthoquinone\nconformers_2d = generate_2d_conformers(mol_2d)\n\nif !isempty(conformers_2d)\n    coords_2d = conformers_2d[1].molecule.props[:coordinates_2d]\n    println(\"\\n2D coordinates for naphthoquinone: $(size(coords_2d))\")\nend","category":"page"},{"location":"examples/#Conformer-Energy-Analysis","page":"Practical Examples","title":"Conformer Energy Analysis","text":"","category":"section"},{"location":"examples/","page":"Practical Examples","title":"Practical Examples","text":"# Analyze conformer energies and geometry\nif !isempty(conformers)\n    energies = [conf.conformer_result.energy for conf in conformers]\n\n    println(\"\\nConformer Energy Analysis:\")\n    println(\"Number of conformers: $(length(energies))\")\n    println(\"Energy range: $(round(minimum(energies), digits=2)) - $(round(maximum(energies), digits=2)) kcal/mol\")\n    println(\"Energy span: $(round(maximum(energies) - minimum(energies), digits=2)) kcal/mol\")\n\n    # Count converged conformers\n    converged_count = sum(conf.conformer_result.converged for conf in conformers)\n    println(\"Converged conformers: $converged_count/$(length(conformers))\")\n\n    # Energy distribution\n    low_energy = sum(e < (minimum(energies) + 2.0) for e in energies)\n    println(\"Low energy conformers (< 2 kcal/mol above minimum): $low_energy\")\nend","category":"page"},{"location":"#MoleculeFlow.jl","page":"Home","title":"MoleculeFlow.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MoleculeFlow.jl is a Julia library for cheminformatics, providing  It enables common molecular manipulation tasks, such as reading/writing, descriptor calculation, fingerprint generation, similarity analysis, and others.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Info\nThis library is based on the rdkit and PythonCall. Author sees little sense in trying to implement things from scratch, as rdkit has been, is, and very likely will continue being the benchmark cheminformatics library in the future. The point of the library is two-fold: 1) Provide a pleasant and user-friendly julian interface that is very easy to extend and/or build upon using a reliable source library. 2) Provide cheminformatics functionality that is not straightforward to implement in in rdkit.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MoleculeFlow\")","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the Getting Started for a basic overview\nSee Examples for some practical use cases\nBrowse the API Reference for complete function documentation","category":"page"},{"location":"api/drawing/#Molecular-Visualization-and-Drawing","page":"Drawing & Visualization","title":"Molecular Visualization and Drawing","text":"","category":"section"},{"location":"api/drawing/","page":"Drawing & Visualization","title":"Drawing & Visualization","text":"Functions for visualizing and drawing molecular structures in various formats.","category":"page"},{"location":"api/drawing/#Molecule-to-Image","page":"Drawing & Visualization","title":"Molecule to Image","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.mol_to_image","page":"Drawing & Visualization","title":"MoleculeFlow.mol_to_image","text":"mol_to_image(mol::Molecule; kwargs...) -> Matrix{RGB{N0f8}}\n\nRender a molecule as a 2D image with various customization options.\n\nArguments\n\nmol::Molecule: The molecule to render\nsize::Tuple=(300, 300): Image size (width, height) in pixels\nkekulize::Bool=true: Whether to kekulize the molecule before drawing\nwedge_bonds::Bool=true: Whether to draw wedge bonds for stereochemistry\nhighlight_atoms::Union{Vector{Int},Nothing}=nothing: Atom indices to highlight (1-based)\nhighlight_bonds::Union{Vector{Int},Nothing}=nothing: Bond indices to highlight (1-based)\nhighlight_atom_colors::Union{Dict,Nothing}=nothing: Custom colors for highlighted atoms\nhighlight_bond_colors::Union{Dict,Nothing}=nothing: Custom colors for highlighted bonds\nuse_svg::Bool=false: Whether to use SVG rendering (returns SVG string instead of image)\n\nReturns\n\nMatrix{RGB{N0f8}}: RGB image matrix (if use_svg=false)\nString: SVG string (if use_svg=true)\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nimg = mol_to_image(mol)\nimg_highlighted = mol_to_image(mol; highlight_atoms = [1, 3])\nsvg_str = mol_to_image(mol; use_svg = true)\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Molecule-to-SVG","page":"Drawing & Visualization","title":"Molecule to SVG","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.mol_to_svg","page":"Drawing & Visualization","title":"MoleculeFlow.mol_to_svg","text":"mol_to_svg(mol::Molecule; kwargs...) -> String\n\nRender a molecule as an SVG string.\n\nArguments\n\nmol::Molecule: The molecule to render\nsize::Tuple=(300, 300): Image size (width, height) in pixels\nkekulize::Bool=true: Whether to kekulize the molecule before drawing\nwedge_bonds::Bool=true: Whether to draw wedge bonds for stereochemistry\nhighlight_atoms::Union{Vector{Int},Nothing}=nothing: Atom indices to highlight\nhighlight_bonds::Union{Vector{Int},Nothing}=nothing: Bond indices to highlight\n\nReturns\n\nString: SVG representation of the molecule\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nsvg_str = mol_to_svg(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Molecules-to-Grid-Image","page":"Drawing & Visualization","title":"Molecules to Grid Image","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.mols_to_grid_image","page":"Drawing & Visualization","title":"MoleculeFlow.mols_to_grid_image","text":"mols_to_grid_image(mols::Vector{Union{Molecule,Missing}}; kwargs...) -> Matrix{RGB{N0f8}}\n\nRender multiple molecules in a grid layout.\n\nArguments\n\nmols::Vector{Union{Molecule,Missing}}: Vector of molecules to render\nsub_img_size::Tuple=(200, 200): Size of each individual molecule image\nmols_per_row::Int=3: Number of molecules per row in the grid\nlegends::Union{Vector{String},Nothing}=nothing: Text labels for each molecule\nhighlight_atom_lists::Union{Vector,Nothing}=nothing: Lists of atoms to highlight for each molecule\nhighlight_bond_lists::Union{Vector,Nothing}=nothing: Lists of bonds to highlight for each molecule\nuse_svg::Bool=false: Whether to use SVG rendering\n\nReturns\n\nMatrix{RGB{N0f8}}: RGB image matrix (if use_svg=false)\nString: SVG string (if use_svg=true)\n\nExamples\n\nmols = [mol_from_smiles(\"CCO\"), mol_from_smiles(\"c1ccccc1\")]\nimg = mols_to_grid_image(mols; legends = [\"Ethanol\", \"Benzene\"])\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Highlight-Substructure","page":"Drawing & Visualization","title":"Highlight Substructure","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.highlight_substructure","page":"Drawing & Visualization","title":"MoleculeFlow.highlight_substructure","text":"highlight_substructure(mol::Molecule, pattern::Union{Molecule,String}; kwargs...) -> Matrix{RGB{N0f8}}\n\nDraw a molecule with a substructure pattern highlighted.\n\nArguments\n\nmol::Molecule: The molecule to render\npattern::Union{Molecule,String}: Substructure pattern (Molecule or SMARTS string)\nsize::Tuple=(300, 300): Image size\nhighlight_color::String=\"yellow\": Color for highlighting (yellow, red, blue, etc.)\nuse_svg::Bool=false: Whether to return SVG instead of image matrix\n\nReturns\n\nMatrix{RGB{N0f8}} or String: Rendered molecule with highlighted substructure\n\nExamples\n\nmol = mol_from_smiles(\"c1ccc(O)cc1\")  # Phenol\nimg = highlight_substructure(mol, \"[OH]\")\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Draw-Molecule-with-Atom-Labels","page":"Drawing & Visualization","title":"Draw Molecule with Atom Labels","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.draw_molecule_with_atom_labels","page":"Drawing & Visualization","title":"MoleculeFlow.draw_molecule_with_atom_labels","text":"draw_molecule_with_atom_labels(mol::Molecule; kwargs...) -> Matrix{RGB{N0f8}}\n\nDraw a molecule with atom indices labeled.\n\nArguments\n\nmol::Molecule: The molecule to render\nsize::Tuple=(300, 300): Image size\nlabel_atoms::Bool=true: Whether to show atom indices\nlabel_bonds::Bool=false: Whether to show bond indices\nuse_svg::Bool=false: Whether to return SVG\n\nReturns\n\nMatrix{RGB{N0f8}} or String: Rendered molecule with labels\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nimg = draw_molecule_with_atom_labels(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Draw-Similarity-Map","page":"Drawing & Visualization","title":"Draw Similarity Map","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.draw_similarity_map","page":"Drawing & Visualization","title":"MoleculeFlow.draw_similarity_map","text":"draw_similarity_map(mol1::Molecule, mol2::Molecule; kwargs...) -> Matrix{RGB{N0f8}}\n\nDraw two molecules side by side highlighting their most common substructure.\n\nArguments\n\nmol1::Molecule: First molecule\nmol2::Molecule: Second molecule\nsize::Tuple=(600, 300): Total image size\nuse_svg::Bool=false: Whether to return SVG\n\nReturns\n\nMatrix{RGB{N0f8}} or String: Side-by-side comparison with common substructure highlighted\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nimg = draw_similarity_map(mol1, mol2)\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Draw-Functional-Groups","page":"Drawing & Visualization","title":"Draw Functional Groups","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.draw_functional_groups","page":"Drawing & Visualization","title":"MoleculeFlow.draw_functional_groups","text":"draw_functional_groups(mol::Molecule; kwargs...) -> Matrix{RGB{N0f8}}\n\nDraw a molecule with functional groups highlighted in different colors.\n\nArguments\n\nmol::Molecule: The molecule to render\nsize::Tuple=(300, 300): Image size\nfunctional_groups::Vector{String}=[\"[OH]\", \"[C=O]\", \"[NH2]\", \"[COOH]\"]: SMARTS patterns for functional groups\ncolors::Vector{String}=[\"red\", \"blue\", \"green\", \"orange\"]: Colors for each functional group\nuse_svg::Bool=false: Whether to return SVG\n\nReturns\n\nMatrix{RGB{N0f8}} or String: Rendered molecule with highlighted functional groups\n\nExamples\n\nmol = mol_from_smiles(\"CC(=O)O\")  # Acetic acid\nimg = draw_functional_groups(mol)\n\n\n\n\n\n","category":"function"},{"location":"api/drawing/#Save-Molecule-Image","page":"Drawing & Visualization","title":"Save Molecule Image","text":"","category":"section"},{"location":"api/drawing/#MoleculeFlow.save_molecule_image","page":"Drawing & Visualization","title":"MoleculeFlow.save_molecule_image","text":"save_molecule_image(mol::Molecule, filepath::String; kwargs...)\n\nSave a molecule image to a file.\n\nArguments\n\nmol::Molecule: The molecule to render\nfilepath::String: Output file path (supports .png, .svg)\nsize::Tuple=(300, 300): Image size\nkwargs...: Additional arguments passed to drawing functions\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nsave_molecule_image(mol, \"ethanol.png\")\nsave_molecule_image(mol, \"ethanol.svg\"; highlight_atoms = [1, 3])\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Substructure-Search","page":"Substructure Search","title":"Substructure Search","text":"","category":"section"},{"location":"api/substructure/","page":"Substructure Search","title":"Substructure Search","text":"Functions for finding substructures and patterns in molecules.","category":"page"},{"location":"api/substructure/#Has-Substructure-Match","page":"Substructure Search","title":"Has Substructure Match","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.has_substructure_match","page":"Substructure Search","title":"MoleculeFlow.has_substructure_match","text":"has_substructure_match(mol::Molecule, pattern::Molecule) -> Union{Bool,Missing}\nhas_substructure_match(mol::Molecule, pattern_smarts::String) -> Union{Bool,Missing}\n\nCheck if a molecule contains a substructure pattern.\n\nArguments\n\nmol::Molecule: The molecule to search in\npattern::Molecule or pattern_smarts::String: The substructure pattern as a Molecule or SMARTS string\n\nReturns\n\nUnion{Bool,Missing}: true if pattern is found, false otherwise, missing if molecules are invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")  # Ethanol\nhas_oh = has_substructure_match(mol, \"[OH]\")\nhas_benzene = has_substructure_match(mol, \"c1ccccc1\")  # false\n\nNotes\n\nSMARTS patterns are more flexible than SMILES for substructure searching\nCase-sensitive: 'c' = aromatic carbon, 'C' = aliphatic carbon\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Get-Substructure-Matches","page":"Substructure Search","title":"Get Substructure Matches","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.get_substructure_matches","page":"Substructure Search","title":"MoleculeFlow.get_substructure_matches","text":"get_substructure_matches(mol::Molecule, pattern::Union{Molecule,String}; unique_matches::Bool=true) -> Union{Vector{Vector{Int}},Missing}\n\nFind all substructure matches and return atom indices for each match.\n\nArguments\n\nmol::Molecule: The molecule to search in\npattern::Union{Molecule,String}: The substructure pattern\nunique_matches::Bool=true: Whether to return only unique matches\n\nReturns\n\nUnion{Vector{Vector{Int}},Missing}: Vector of vectors containing 1-based atom indices for each match\n\nExamples\n\nmol = mol_from_smiles(\"c1ccc(O)cc1\")  # Phenol\nmatches = get_substructure_matches(mol, \"[OH]\")\n# Returns atom indices where OH pattern is found\n\nNotes\n\nReturns 1-based atom indices (Julia convention)\nEach inner vector contains atom indices for one match\nEmpty vector if no matches found\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Get-Substructure-Match","page":"Substructure Search","title":"Get Substructure Match","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.get_substructure_match","page":"Substructure Search","title":"MoleculeFlow.get_substructure_match","text":"get_substructure_match(mol::Molecule, pattern::Union{Molecule,String}) -> Union{Vector{Int}, Missing}\n\nGet the first substructure match of a pattern in a molecule.\n\nArguments\n\nmol::Molecule: The molecule to search in\npattern::Union{Molecule,String}: The substructure pattern as a Molecule or SMARTS string\n\nReturns\n\nVector{Int}: 1-based atom indices of the first match\nmissing: If no match is found or molecules are invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nmatch = get_substructure_match(mol, \"[OH]\")  # Returns [3] (oxygen index)\n\nNotes\n\nReturns only the first match found\nUse get_substructure_matches to get all matches\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Maximum-Common-Substructure","page":"Substructure Search","title":"Maximum Common Substructure","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.maximum_common_substructure","page":"Substructure Search","title":"MoleculeFlow.maximum_common_substructure","text":"maximum_common_substructure(mol1::Molecule, mol2::Molecule) -> Union{Molecule, Missing}\n\nFind the maximum common substructure (MCS) between two molecules.\n\nArguments\n\nmol1::Molecule: First molecule\nmol2::Molecule: Second molecule\n\nReturns\n\nMolecule: The maximum common substructure as a new Molecule object\nmissing: If no common substructure is found or molecules are invalid\n\nExamples\n\nmol1 = mol_from_smiles(\"CCO\")\nmol2 = mol_from_smiles(\"CCC\")\nmcs = maximum_common_substructure(mol1, mol2)  # Common C-C substructure\n\nNotes\n\nUses RDKit's FindMCS algorithm\nReturns the largest substructure common to both molecules\nUseful for scaffold analysis and lead optimization\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Has-Substructure-Matches","page":"Substructure Search","title":"Has Substructure Matches","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.has_substructure_matches","page":"Substructure Search","title":"MoleculeFlow.has_substructure_matches","text":"has_substructure_matches(mols::Vector{Union{Molecule,Missing}}, pattern::Union{Molecule,String}) -> Vector{Union{Bool,Missing}}\n\nCheck for substructure matches across a vector of molecules.\n\nArguments\n\nmols::Vector{Union{Molecule,Missing}}: Vector of molecules to search\npattern::Union{Molecule,String}: The substructure pattern to search for\n\nReturns\n\nVector{Union{Bool,Missing}}: Boolean vector indicating matches for each molecule\n\nExamples\n\nmols = [mol_from_smiles(\"CCO\"), mol_from_smiles(\"CCC\"), mol_from_smiles(\"CC(O)C\")]\nmatches = has_substructure_matches(mols, \"[OH]\")  # [true, false, true]\n\nNotes\n\nVectorized version of has_substructure_match\nUseful for filtering large molecular datasets\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Filter-by-Substructure","page":"Substructure Search","title":"Filter by Substructure","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.filter_by_substructure","page":"Substructure Search","title":"MoleculeFlow.filter_by_substructure","text":"filter_by_substructure(mols::Vector{Union{Molecule,Missing}}, pattern::Union{Molecule,String}) -> Vector{Union{Molecule,Missing}}\n\nFilter molecules that contain a specific substructure pattern.\n\nArguments\n\nmols::Vector{Union{Molecule,Missing}}: Vector of molecules to filter\npattern::Union{Molecule,String}: The substructure pattern to filter by\n\nReturns\n\nVector{Union{Molecule,Missing}}: Filtered vector containing only molecules with the pattern\n\nExamples\n\nmols = [mol_from_smiles(\"CCO\"), mol_from_smiles(\"CCC\"), mol_from_smiles(\"CC(O)C\")]\nalcohols = filter_by_substructure(mols, \"[OH]\")  # Returns [CCO, CC(O)C]\n\nNotes\n\nConvenient wrapper around has_substructure_matches\nUseful for creating focused molecular libraries\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Has-Functional-Group","page":"Substructure Search","title":"Has Functional Group","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.has_functional_group","page":"Substructure Search","title":"MoleculeFlow.has_functional_group","text":"has_functional_group(mol::Molecule, group::Symbol) -> Union{Bool, Missing}\n\nCheck if a molecule contains a specific functional group.\n\nArguments\n\nmol::Molecule: The molecule to analyze\ngroup::Symbol: The functional group to search for (see FUNCTIONAL_GROUPS for available groups)\n\nReturns\n\nUnion{Bool, Missing}: true if the functional group is present, false otherwise, missing if molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nhas_functional_group(mol, :alcohol)  # true\nhas_functional_group(mol, :ketone)   # false\n\nAvailable Functional Groups\n\nSee FUNCTIONAL_GROUPS constant for the complete list of 100+ available functional groups including:\n\n:alcohol, :carboxylic_acid, :ester, :ether, :aldehyde, :ketone\n:amine_primary, :amine_secondary, :amine_tertiary, :amide, :nitrile\n:benzene, :pyridine, :furan, :thiophene, :imidazole, :pyrrole\n:thiol, :sulfide, :disulfide, :sulfoxide, :sulfone, :sulfonamide\n:phosphate, :phosphonate, :phosphine, :phosphine_oxide\n:fluoride, :chloride, :bromide, :iodide, :trifluoromethyl\n:nitro, :nitroso, :azide, :epoxide, :steroid_core, :beta_lactam\n:morpholine, :piperidine, :pyrrolidine, :tetrahydrofuran\n:peptide_bond, :alpha_amino_acid, :glucose_like, :fatty_acid\n:benzodiazepine_core, :barbiturate_core, :sulfonamide_drug\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Get-Functional-Groups","page":"Substructure Search","title":"Get Functional Groups","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.get_functional_groups","page":"Substructure Search","title":"MoleculeFlow.get_functional_groups","text":"get_functional_groups(mol::Molecule) -> Union{Dict{Symbol, Bool}, Missing}\n\nGet a dictionary of all functional groups present in a molecule.\n\nArguments\n\nmol::Molecule: The molecule to analyze\n\nReturns\n\nDict{Symbol, Bool}: Dictionary mapping functional group symbols to their presence (true/false)\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"CC(=O)O\")  # Acetic acid\ngroups = get_functional_groups(mol)\n# Returns Dict(:carboxylic_acid => true, :alcohol => false, ...)\n\nNotes\n\nChecks for all functional groups defined in FUNCTIONAL_GROUPS\nUseful for quick functional group profiling\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Functional-Groups","page":"Substructure Search","title":"Functional Groups","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.FUNCTIONAL_GROUPS","page":"Substructure Search","title":"MoleculeFlow.FUNCTIONAL_GROUPS","text":"FUNCTIONAL_GROUPS\n\nA comprehensive dictionary containing 100+ predefined functional group SMARTS patterns organized by category.\n\nBasic Functional Groups\n\n:alcohol, :phenol, :carboxylic_acid, :ester, :ether, :aldehyde, :ketone\n:amine_primary, :amine_secondary, :amine_tertiary, :amide, :nitrile\n\nSulfur-Containing Groups\n\n:thiol, :sulfide, :disulfide, :sulfoxide, :sulfone\n:sulfonamide, :sulfonate, :sulfonic_acid, :sulfonyl_chloride\n\nPhosphorus-Containing Groups\n\n:phosphate, :phosphonate, :phosphine, :phosphine_oxide\n\nHalogen-Containing Groups\n\n:fluoride, :chloride, :bromide, :iodide, :trifluoromethyl, :trichloromethyl\n\nAdvanced Nitrogen Groups\n\n:nitro, :nitroso, :azide, :diazo, :hydrazine, :hydroxylamine\n:imine, :oxime, :enamine, :guanidine, :urea, :carbamate\n:isocyanate, :isothiocyanate\n\nAdvanced Oxygen Groups\n\n:peroxide, :acetal, :ketal, :hemiacetal, :hemiketal\n:anhydride, :carbonate, :carbamate_ester\n\nCarbon-Carbon Multiple Bonds\n\n:alkene, :alkyne, :allene, :conjugated_diene\n\n5-Membered Aromatic Heterocycles\n\n:furan, :thiophene, :pyrrole, :imidazole, :pyrazole\n:oxazole, :isoxazole, :thiazole, :isothiazole\n:triazole_1_2_3, :triazole_1_2_4, :tetrazole\n\n6-Membered Aromatic Heterocycles\n\n:benzene, :pyridine, :pyrimidine, :pyrazine, :pyridazine, :triazine\n\nFused Aromatic Systems\n\n:naphthalene, :anthracene, :phenanthrene, :quinoline, :isoquinoline\n:indole, :benzofuran, :benzothiophene, :purine\n\nSaturated Heterocycles\n\n:tetrahydrofuran, :tetrahydropyran, :pyrrolidine, :piperidine\n:morpholine, :piperazine, :azetidine, :oxetane, :thietane\n\nBiomolecule Patterns\n\n:glucose_like, :anomeric_carbon, :glycosidic_bond (sugars)\n:peptide_bond, :alpha_amino_acid, :proline_like (proteins)\n:fatty_acid, :fatty_acid_long, :triglyceride_like (lipids)\n\nPharmaceutical Patterns\n\n:benzodiazepine_core, :beta_lactam, :sulfonamide_drug, :barbiturate_core\n\nNatural Product Patterns\n\n:steroid_core, :flavonoid_core, :coumarin, :chromone\n\nReactive Groups and Electrophiles\n\n:epoxide, :aziridine, :cyclopropane, :michael_acceptor\n:alpha_beta_unsaturated_carbonyl\n\nProtecting Groups (Synthetic Chemistry)\n\n:tert_butyl, :benzyl, :acetyl, :benzoyl, :tosyl\n:boc, :cbz, :fmoc\n\nExamples\n\nmol = mol_from_smiles(\"CCO\")\nhas_functional_group(mol, :alcohol)  # true\n# Basic functional groups\ndrug = mol_from_smiles(\"CC(=O)Nc1ccc(O)cc1\")  # Acetaminophen\nhas_functional_group(drug, :phenol)     # true\nhas_functional_group(drug, :amide)      # true\nhas_functional_group(drug, :benzene)    # true\n\n# Get all functional groups at once\nall_groups = get_functional_groups(drug)\n\nNotes\n\nContains 100+ functional group patterns covering basic to advanced organic chemistry\nSMARTS patterns are carefully designed for specificity and broad applicability\nUseful for drug discovery, natural product analysis, and chemical library filtering    # Sulfur-containing groups\nPatterns organized by chemical similarity and complexity\n\n\n\n\n\n","category":"constant"},{"location":"api/substructure/#Get-Ring-Info","page":"Substructure Search","title":"Get Ring Info","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.get_ring_info","page":"Substructure Search","title":"MoleculeFlow.get_ring_info","text":"get_ring_info(mol::Molecule) -> Union{Dict, Missing}\n\nGet detailed information about rings in a molecule.\n\nArguments\n\nmol::Molecule: The molecule to analyze\n\nReturns\n\nDict: Dictionary containing ring information with keys:\n:num_rings: Total number of rings\n:atom_rings: Vector of vectors containing 1-based atom indices for each ring\n:bond_rings: Vector of vectors containing 1-based bond indices for each ring\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\nring_info = get_ring_info(mol)\n# Returns Dict(:num_rings => 1, :atom_rings => [[1,2,3,4,5,6]], :bond_rings => [[1,2,3,4,5,6]])\n\nNotes\n\nProvides comprehensive ring analysis\nUseful for understanding molecular topology\n\n\n\n\n\n","category":"function"},{"location":"api/substructure/#Is-Ring-Aromatic","page":"Substructure Search","title":"Is Ring Aromatic","text":"","category":"section"},{"location":"api/substructure/#MoleculeFlow.is_ring_aromatic","page":"Substructure Search","title":"MoleculeFlow.is_ring_aromatic","text":"is_ring_aromatic(mol::Molecule, ring_atoms::Vector{Int}) -> Union{Bool, Missing}\n\nCheck if a specific ring in a molecule is aromatic.\n\nArguments\n\nmol::Molecule: The molecule containing the ring\nring_atoms::Vector{Int}: 1-based indices of atoms forming the ring\n\nReturns\n\nBool: true if the ring is aromatic, false otherwise\nmissing: If molecule is invalid\n\nExamples\n\nmol = mol_from_smiles(\"c1ccccc1\")  # Benzene\nring_info = get_ring_info(mol)\nis_aromatic = is_ring_aromatic(mol, ring_info[:atom_rings][1])  # true\n\nNotes\n\nChecks if all atoms in the ring have aromatic character\nUseful for distinguishing aromatic from aliphatic rings\n\n\n\n\n\n","category":"function"}]
}
